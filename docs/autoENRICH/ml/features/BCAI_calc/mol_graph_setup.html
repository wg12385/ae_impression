<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>autoENRICH.ml.features.BCAI_calc.mol_graph_setup API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>autoENRICH.ml.features.BCAI_calc.mol_graph_setup</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python

## Copyright (c) 2017 Robert Bosch GmbH
## All rights reserved.
##
## This source code is licensed under the MIT license found in the
## LICENSE file in the root directory of this source tree.

import collections
import gzip
import itertools
import json
import os
import pickle
import sys

import numpy as np
import pandas as pd
import rdkit
import autoENRICH.ml.features.BCAI_calc.xyz2mol as x2m

# Due to some compatibility issues between rdkit/pybel and torch, we have to load them as needed.
# Rules are meant to be broken, including best-programming practices :)


bond_order_dict = { rdkit.Chem.rdchem.BondType.SINGLE: 1,
                                        rdkit.Chem.rdchem.BondType.AROMATIC: 1.5,
                                        rdkit.Chem.rdchem.BondType.DOUBLE: 2,
                                        rdkit.Chem.rdchem.BondType.TRIPLE: 3}

atomic_num_dict = { &#39;H&#39;:1, &#39;C&#39;:6, &#39;N&#39;:7, &#39;O&#39;:8, &#39;F&#39;:9 }
# These were mistaken or too small datasets, so we are relabeling them.
classification_corrections = {
                                          &#39;1JHN_2_2_1_1&#39;:&#39;1JHN_3_2_2_1&#39;,
                                          &#39;3JHN_4.5_3_1.5_1.5&#39;:&#39;3JHN_4_3_1.5_1.5&#39;,
                                          &#39;2JHC_3_3_1_1&#39;:&#39;2JHC_4_3_2_1&#39;,
                                          &#39;3JHC_3_3_1_1&#39;:&#39;3JHC_4_3_2_1&#39;,
                                          &#39;3JHC_4_2_2_2&#39;:&#39;3JHC_4_2_3_1&#39;}
# These have less than 1000 between train and test, so we will drop the subtypes
small_longtypes = {&#39;2JHN_4.5_2_3_1.5&#39;, &#39;3JHN_4_2_3_1&#39;, &#39;2JHN_4_2_3_1&#39;,
                                   &#39;2JHN_4.5_3_1.5_1.5&#39;, &#39;2JHN_4_3_2_1&#39;, &#39;3JHN_4_4_1_1&#39;,
                                   &#39;3JHN_4_3_2_1&#39;, &#39;2JHN_4_4_1_1&#39;, &#39;3JHN_4.5_2_3_1.5&#39;,
                                   &#39;2JHN_4_2_2_2&#39;, &#39;3JHN_4_2_2_2&#39;, &#39;1JHN_4_3_2_1&#39;,
                                   &#39;1JHN_4_4_1_1&#39;, &#39;2JHN_3_1_3_0&#39;}
(MAX_ATOM_COUNT,MAX_BOND_COUNT,MAX_TRIPLET_COUNT,MAX_QUAD_COUNT) = (100, 800, 500, 400)


def make_structure_dict(atoms_dataframe):
        &#34;&#34;&#34;Convert from structures.csv output to a dictionary data storage.

        Args:
                atoms_dataframe: The dataframe corresponding to structures.csv

        Returns:
                dict: Mapping of molecule name to molecule properties.

        &#34;&#34;&#34;
        atoms = atoms_dataframe.sort_values([&#34;molecule_name&#34;, &#34;atom_index&#34;])  # ensure ordering is consistent
        # Make a molecule-based dictionary of the information
        structure_dict = collections.defaultdict(lambda: {&#34;symbols&#34;:[],&#34;positions&#34;:[],&#34;conn&#34;:[]})
        for index,row in atoms.iterrows():
                structure_dict[row[&#34;molecule_name&#34;]][&#34;symbols&#34;].append(row[&#34;atom&#34;])
                structure_dict[row[&#34;molecule_name&#34;]][&#34;positions&#34;].append([row[&#34;x&#34;],row[&#34;y&#34;],row[&#34;z&#34;]])
                structure_dict[row[&#34;molecule_name&#34;]][&#34;conn&#34;].append(row[&#34;conn&#34;])

        return structure_dict


def enhance_structure_dict(structure_dict):
        &#34;&#34;&#34;Add derived information to the structure dictionary.

        Args:
                structure_dict: Output of :func:`make_structure_dict`.

        Returns:
                dict: The same, modified in-place, with derived information (e.g. atom distances).

        Caution: If torch is imported at the same time as this is run, you may get a segmentation fault. Complain to pybel or rdkit, I suppose.
        &#34;&#34;&#34;

        import pybel

        atomic_num_dict = { &#39;H&#39;:1, &#39;C&#39;:6, &#39;N&#39;:7, &#39;O&#39;:8, &#39;F&#39;:9 }


        for molecule_name in structure_dict:

                # positions - array (N,3) of Cartesian positions
                molecule = structure_dict[molecule_name]
                positions = np.array(molecule[&#39;positions&#39;])
                conn = np.array(molecule[&#39;conn&#39;])
                n_atom = positions.shape[0]
                molecule[&#39;positions&#39;] = positions

                # distances - array (N,N) of distances between atoms
                pos1 = np.tile(positions, (n_atom,1,1) )
                pos2 = np.transpose(pos1, (1,0,2) )
                dist = np.linalg.norm(pos1 - pos2, axis=-1)
                molecule[&#39;distances&#39;] = dist

                # angle - array (N,) of angles to the 2 closest atoms
                sorted_j = np.argsort(dist, axis=-1)
                relpos1 = positions[sorted_j[:,1],:] - positions[sorted_j[:,0],:]
                relpos2 = positions[sorted_j[:,2],:] - positions[sorted_j[:,0],:]
                cos = np.sum(relpos1*relpos2,axis=1) / (np.linalg.norm(relpos1,axis=1) * np.linalg.norm(relpos2,axis=1))
                angle = np.arccos( np.clip(cos,-1.0,1.0) ).reshape((n_atom,1)) / np.pi
                molecule[&#39;angle&#39;] = angle[:,0]

                # bond orders - array (N,N) of the bond order (0 for no chemical bond)
                # Note this relies on a few manual corrections
                molecule[&#39;bond_orders&#39;] = np.zeros((n_atom,n_atom))
                atomicNumList = [atomic_num_dict[symbol] for symbol in molecule[&#39;symbols&#39;]]

                for atom0 in range(len(molecule[&#39;symbols&#39;])):
                        for atom1 in range(len(molecule[&#39;symbols&#39;])):

                                molecule[&#39;bond_orders&#39;][atom0,atom1] = conn[atom0][atom1]
                                molecule[&#39;bond_orders&#39;][atom1,atom0] = conn[atom1][atom0]

                # Supplementary information for tagging:
                # top_bonds: (N,4 or less) bond orders of the top 4 bonds, for each atom
                # bond_ids: (N,4): Label the atom with the following 4 linear transform of top_bonds:
                #   * total num bonds (valence), counting double as 2
                #   * total num bonded neighbors, counting double as 1
                #   * largest order
                #   * second largest order.
                molecule[&#39;top_bonds&#39;] = np.sort(molecule[&#39;bond_orders&#39;],axis=-1)[:,-1:-5:-1]
                molecule[&#39;bond_ids&#39;] = np.hstack((molecule[&#39;top_bonds&#39;].sum(axis=-1)[:,np.newaxis],
                                                                                  np.sum(molecule[&#39;top_bonds&#39;]&gt;1e-3,axis=-1)[:,np.newaxis],
                                                                                  molecule[&#39;top_bonds&#39;][:,:2]))
                # long_symbols (N,) string relabel of the symbol straight from bond_ids
                molecule[&#39;long_symbols&#39;] = [&#39;_&#39;.join([
                        molecule[&#39;symbols&#39;][i]]+[str(x) for x in molecule[&#39;bond_ids&#39;][i]])
                                                                        for i in range(n_atom)]
                chem_bond_atoms = [sorted([molecule[&#39;symbols&#39;][i] for i in molecule[&#39;bond_orders&#39;][atom_index].nonzero()[0]])
                                                   for atom_index in range(n_atom)]
                molecule[&#39;sublabel_atom&#39;] = [&#39;-&#39;.join([molecule[&#39;long_symbols&#39;][atom_index]]+chem_bond_atoms[atom_index])
                                                                        for atom_index in range(n_atom)]

                # pybel information. I think we only end up using Gastiger charges.
                # Each of these is (N,) arrays
                # Convert to xyz string for pybel&#39;s I/O
                xyz = str(n_atom)+&#39;\n\n&#39; + &#39;\n&#39;.join([ &#39; &#39;.join( [
                                str(molecule[&#39;symbols&#39;][i]),
                                str(molecule[&#39;positions&#39;][i,0]),
                                str(molecule[&#39;positions&#39;][i,1]),
                                str(molecule[&#39;positions&#39;][i,2])] )
                                for i in range(n_atom)])

                mol = pybel.readstring(&#39;xyz&#39;,xyz)
                molecule[&#39;charges&#39;] = [mol.atoms[i].partialcharge for i in range(n_atom)]
                molecule[&#39;spins&#39;] = [mol.atoms[i].spin for i in range(n_atom)]
                molecule[&#39;heavyvalences&#39;] = [mol.atoms[i].heavyvalence for i in range(n_atom)]
                molecule[&#39;heterovalences&#39;] = [mol.atoms[i].heterovalence for i in range(n_atom)]
                molecule[&#39;valences&#39;] = [mol.atoms[i].valence for i in range(n_atom)]
                molecule[&#39;hyb_types&#39;] = [mol.atoms[i].type for i in range(n_atom)]

        return structure_dict


def enhance_atoms(atoms_dataframe,structure_dict):
        &#34;&#34;&#34;Enhance the atoms dataframe by including derived information.

        Args:
                atoms_dataframe: Pandas dataframe read from structures.csv.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: Same dataframe, modified in-place, with derived information added.

        &#34;&#34;&#34;
        assert int(atoms_dataframe.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_ATOM_COUNT
        for key in [&#39;distances&#39;,&#39;angle&#39;, &#39;bond_orders&#39;, &#39;top_bonds&#39;, &#39;bond_ids&#39;, &#39;long_symbols&#39;,&#39;sublabel_atom&#39;,
                                &#39;charges&#39;, &#39;spins&#39;, &#39;heavyvalences&#39;, &#39;heterovalences&#39;, &#39;valences&#39;, &#39;hyb_types&#39;]:
                newkey = key if key[-1]!=&#39;s&#39; else key[:-1]
                atoms_dataframe[newkey] = atoms_dataframe.apply(lambda x:
                                                                                                                structure_dict[x[&#39;molecule_name&#39;]][key][x[&#39;atom_index&#39;]],
                                                                                                                axis=1)
                atoms_dataframe.rename(columns={&#39;long_symbol&#39;:&#39;labeled_atom&#39;},inplace=True)
        return atoms_dataframe


def enhance_bonds(bond_dataframe,structure_dict):
        &#34;&#34;&#34;Enhance the bonds dataframe by including derived information.

        Args:
                bond_dataframe: Pandas dataframe read from train.csv or test.csv.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: Same dataframe, modified in-place, with derived information added.

        &#34;&#34;&#34;
        bond_dataframe.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;],inplace=True)
        assert int(bond_dataframe.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_BOND_COUNT
        new_columns = collections.defaultdict(list)
        for index,row in bond_dataframe.iterrows():
                molecule_name, iatom0, iatom1 = row[&#39;molecule_name&#39;],row[&#39;atom_index_0&#39;],row[&#39;atom_index_1&#39;]
                if &#39;predict&#39; not in structure_dict[molecule_name]:
                        structure_dict[molecule_name][&#39;predict&#39;] = structure_dict[molecule_name][&#39;bond_orders&#39;] * 0
                structure_dict[molecule_name][&#39;predict&#39;][iatom0,iatom1] = 1
                structure_dict[molecule_name][&#39;predict&#39;][iatom1,iatom0] = 1
                long_symbols = [structure_dict[molecule_name][&#39;long_symbols&#39;][x] for x in [iatom0,iatom1]]

                # labeled_type
                if all([x[0]==&#39;H&#39; for x in long_symbols]):
                        lt = row[&#39;type&#39;]
                elif not any([x[0]==&#39;H&#39; for x in long_symbols]):
                        raise ValueError(&#34;No hydrogen found in {}&#34;.format(row))
                else:
                        ls = [x for x in long_symbols if x[0]!=&#39;H&#39;][0]
                        lt = row[&#34;type&#34;] + ls[1:].replace(&#39;.0&#39;,&#39;&#39;)
                        if lt in classification_corrections:
                                lt = classification_corrections[lt]
                        if lt in small_longtypes:
                                lt = lt.split(&#39;_&#39;)[0]
                new_columns[&#34;labeled_type&#34;].append(lt)

                # sublabeled type
                new_columns[&#34;sublabel_type&#34;].append(row[&#39;type&#39;] + &#39;-&#39;+ &#39;-&#39;.join(sorted(long_symbols)))
                # bond order
                new_columns[&#34;bond_order&#34;].append(structure_dict[molecule_name][&#39;bond_orders&#39;][iatom0,iatom1])
                new_columns[&#34;predict&#34;].append(1)
        for key in new_columns:
                bond_dataframe[key] = new_columns[key]
        return bond_dataframe


def add_all_pairs(bond_dataframe,structure_dict):
        &#34;&#34;&#34;Add all pairs of atoms, including those without coupling and without chemical bonds.

        Args:
                bond_dataframe: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with new bonds added.

        &#34;&#34;&#34;
        # NOTE: The convention for id used to be very large numbers for new bonds; now it is negative.
        iadd = -1
        new_data = collections.defaultdict(list)
        for molecule_name in bond_dataframe[&#34;molecule_name&#34;].unique():
                n_atom = len(structure_dict[molecule_name][&#34;symbols&#34;])
                # for backwards compatibility, this is iatom1,iatom0. See make_new_csv.py, write_pairs.
                for iatom1,iatom0 in itertools.combinations(range(n_atom),r=2):
                        if &#39;predict&#39; not in structure_dict[molecule_name]:
                                raise KeyError(&#39;{} has no &#34;predict&#34; value&#39;.format(molecule_name))
                        if structure_dict[molecule_name][&#39;predict&#39;][iatom0,iatom1]:
                                continue  # already got it
                        symbols = [structure_dict[molecule_name][&#39;symbols&#39;][i] for i in [iatom0,iatom1]]
                        bond_order = structure_dict[molecule_name][&#39;bond_orders&#39;][iatom0,iatom1]
                        nottype = &#39;-&#39;.join(sorted(symbols)) + &#39;_&#39; + str(bond_order)

                        row = {&#39;id&#39;:iadd,&#39;molecule_name&#39;:molecule_name,&#39;atom_index_0&#39;:iatom0,&#39;atom_index_1&#39;:iatom1,
                                   &#39;type&#39;:nottype,&#39;labeled_type&#39;:nottype,&#39;sublabel_type&#39;:nottype,
                                   &#39;bond_order&#39;: bond_order,
                                   &#39;predict&#39;:0}
                        if &#39;scalar_coupling_constant&#39; in bond_dataframe:
                                row[&#39;scalar_coupling_constant&#39;] = 0.
                        for k,v in row.items():
                                new_data[k].append(v)
                        iadd -= 1
        new_data = pd.DataFrame(new_data)
        if bond_dataframe.index.name!=&#39;id&#39;:
                bond_dataframe = bond_dataframe.set_index(&#39;id&#39;)
        new_data.set_index(&#39;id&#39;,inplace=True)
        all_data = bond_dataframe.append(new_data,verify_integrity=True,sort=False)
        return all_data


def make_triplets(molecule_list,structure_dict):
        &#34;&#34;&#34;Make the triplet dataframe.

        Args:
                molecule_list: List of molecules to generate.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with triplets and related information. The convention is the bond looks like 1-0-2, where 0 is the central atom.

        &#34;&#34;&#34;
        new_data = collections.defaultdict(list)
        for molecule_name in molecule_list:
                molecule = structure_dict[molecule_name]
                bond_orders = molecule[&#39;bond_orders&#39;]
                short = molecule[&#39;symbols&#39;]
                long = molecule[&#39;long_symbols&#39;]
                for i, atom_bond_order in enumerate(bond_orders):
                        connection_indices = atom_bond_order.nonzero()[0]
                        pairs = itertools.combinations(connection_indices,2)
                        for pair in pairs:
                                j, k = pair[0], pair[1]
                                atom0_short = short[i] + long[i].split(&#39;_&#39;)[2]
                                atom1_short = short[j] + long[j].split(&#39;_&#39;)[2]
                                atom2_short = short[k] + long[k].split(&#39;_&#39;)[2]
                                atom0_long = long[i]
                                atom1_long = long[j]
                                atom2_long = long[k]
                                #labels = [&#39;-&#39;.join([atom1_short,str(atom_bond_order[j])]),
                                #          &#39;-&#39;.join([atom2_short,str(atom_bond_order[k])])]
                                labels = [atom1_short,atom2_short]
                                labels.sort()
                                label = &#39;-&#39;.join([atom0_short]+labels)
                                #sublabels = [&#39;-&#39;.join([atom1_long,str(atom_bond_order[j])]),
                                #             &#39;-&#39;.join([atom2_long,str(atom_bond_order[k])])]
                                sublabels = [atom1_long,atom2_long]
                                sublabels.sort()
                                sublabel = &#39;-&#39;.join([atom0_long]+sublabels)
                                r10 = molecule[&#39;positions&#39;][j] - molecule[&#39;positions&#39;][i]
                                r20 = molecule[&#39;positions&#39;][k] - molecule[&#39;positions&#39;][i]
                                angle = np.sum(r10*r20) / (np.linalg.norm(r10)*np.linalg.norm(r20))
                                angle = np.arccos( np.clip(angle,-1.0,1.0) )
                                row = {&#39;molecule_name&#39;:molecule_name,&#39;atom_index_0&#39;:i,&#39;atom_index_1&#39;:j,&#39;atom_index_2&#39;:k,
                                          &#39;label&#39;:label,&#39;sublabel&#39;:sublabel,&#39;angle&#39;:angle}
                                for k,v in row.items():
                                        new_data[k].append(v)
        ans = pd.DataFrame(new_data)
        ans.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;])
        assert int(ans.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_TRIPLET_COUNT
        return ans


def make_quadruplets(molecule_list,structure_dict):
        &#34;&#34;&#34;Make the quadruplet dataframe.

        Args:
                molecule_list: List of molecules to generate.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with quadruplets and related information. Make quadruplets. Convention is that they are connected 2-0-1-3, where 0,1 are the central atoms and 0-2 is a bond.

        &#34;&#34;&#34;
        new_data = collections.defaultdict(list)
        icount = 0  # for debugging
        for molecule_name in molecule_list:
                molecule = structure_dict[molecule_name]
                bond_orders = molecule[&#39;bond_orders&#39;]
                short = molecule[&#39;symbols&#39;]
                long = molecule[&#39;long_symbols&#39;]
                pos = molecule[&#39;positions&#39;]
                for i,j in zip(*bond_orders.nonzero()):
                        if i &gt; j:
                                continue  # we will get it the other way
                        for i_nei,j_nei in itertools.product(
                                        bond_orders[i].nonzero()[0],bond_orders[j].nonzero()[0]):
                                if j_nei==i or i_nei==j:
                                        continue  # no self
                                # But we could have i_nei==j_nei, which is a triangle
                                # Atomic structure looks like i_nei-i-j-j_nei
                                # There&#39;s an easy way and a quick way.
                                mode = &#39;fast&#39;
                                assert [&#39;test&#39;,&#39;fast&#39;,&#39;slow&#39;].count(mode),&#39;Mode must be one of: test, fast, slow&#39;
                                if [&#39;test&#39;,&#39;slow&#39;].count(mode):
                                        plane_1 = np.cross( pos[i_nei]-pos[i], pos[j]-pos[i])
                                        plane_2 = np.cross( pos[i]-pos[j],pos[j_nei]-pos[j])
                                        if np.allclose(plane_1,0.) or np.allclose(plane_2,0.):
                                                # Planar; not really a dihedral
                                                continue
                                        # Compute the dihedral in radians
                                        costheta = np.dot(plane_1,plane_2) / (
                                                np.linalg.norm(plane_1)*np.linalg.norm(plane_2))
                                        costheta1 = costheta
                                if [&#39;test&#39;,&#39;fast&#39;].count(mode):  # this way is much faster
                                        # Uses some clever algebra
                                        ijpos = np.array([
                                                        pos[i_nei] - pos[i],
                                                        pos[j] - pos[i],
                                                        pos[j_nei] - pos[j],
                                                        ])
                                        # For simplicity, call these a,b,c
                                        dots = np.dot(ijpos,ijpos.T)
                                        # numerator = (a x b).(-b x c)
                                        # denominator = |a x b| |b x c|
                                        # So:
                                        # -(axb).(bxc) = (b.b)(a.c) - (a.b)(b.c)
                                        numerator = dots[1,1]*dots[0,2] - dots[0,1]*dots[1,2]
                                        # |axb|^2=|a|^2|b|^2-(a.b)^2
                                        denominator = np.sqrt( (
                                                        dots[0,0]*dots[1,1]-dots[0,1]**2) * (
                                                        dots[2,2]*dots[1,1]-dots[2,1]**2 ))
                                        if abs(denominator) &lt; 1e-7:
                                                # Planar, not really a dihedral
                                                continue
                                        costheta = numerator / denominator
                                if mode==&#39;test&#39;:
                                        assert abs(costheta-costheta1)&lt;1e-4,&#34;Fancy algebra failed&#34;
                                        icount += 1
                                        if icount &gt; 50000:
                                                raise Exception(&#34;50K counts confirmed.&#34;)
                                assert abs(costheta)&lt;1.0001,&#39;Cos theta too large&#39;
                                dihedral = np.arccos( np.clip(costheta,-1.0,1.0) )
                                # Start labeling
                                label = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei]]),
                                        &#39;_&#39;.join([short[j],short[j_nei]]),
                                        ]))

                                # This definition finds several unique labels in the test set, e.g. &#39;C3_C4_C4_N4&#39;
                                #sublabel = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]+long[i_nei].split(&#39;_&#39;)[1]]),
                                #    &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]+long[j_nei].split(&#39;_&#39;)[1]]),
                                #    ])).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, e.g. C_3_3_1_1_C_C_4_4_1_1_N
                                #sublabel2 = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([long[i],short[i_nei]]),
                                #    &#39;_&#39;.join([long[j],short[j_nei]]),
                                #    ])).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, {&#39;C_O_1_N_C_2_2&#39;,
                                # &#39;N_C_1_N_O_1_2&#39;, &#39;N_N_2_O_C_1_1&#39;}
                                sublabel4 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei],str(bond_orders[i,i_nei].round(1))]),
                                        &#39;_&#39;.join([short[j],short[j_nei],str(bond_orders[j,j_nei].round(1))]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, e.g. C3_C4_1_C4_N4_1_1&#39;
                                #sublabel4 = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]+long[i_nei].split(&#39;_&#39;)[1],
                                #        str(bond_orders[i,i_nei].round(1))]),
                                #    &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]+long[j_nei].split(&#39;_&#39;)[1],
                                #        str(bond_orders[j,j_nei].round(1))]),
                                #    ]) + [str(bond_orders[i,j].round(1))]
                                #    ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei]]),
                                        &#39;_&#39;.join([short[j],short[j_nei]]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel2 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]]),
                                        &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel3 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]]),
                                        &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]]),
                                        ])).replace(&#39;.0&#39;,&#39;&#39;)
                                row = {&#39;molecule_name&#39;:molecule_name,
                                           &#39;atom_index_0&#39;:i,&#39;atom_index_1&#39;:j,&#39;atom_index_2&#39;:i_nei,&#39;atom_index_3&#39;:j_nei,
                                          &#39;label&#39;:label,&#39;sublabel&#39;:sublabel,&#39;sublabel2&#39;:sublabel2,&#39;sublabel3&#39;:sublabel3,
                                           &#39;sublabel4&#39;:sublabel4,&#39;angle&#39;:dihedral}
                                for k,v in row.items():
                                        new_data[k].append(v)
        ans = pd.DataFrame(new_data)
        ans.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;,&#39;atom_index_3&#39;])
        assert int(ans.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_QUAD_COUNT
        return ans


def write_csv(directory,label,atoms,bonds,triplets,quadruplets):
        &#34;&#34;&#34;Write the relevant dataframes to a CSV file.

        Args:
                directory: Directory to write to.
                label (str): How to label the files, e.g. test or train.
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quadruplets: Pandas dataframe created by :func:`make_quadruplets`.

        Returns:
                None

        &#34;&#34;&#34;
        filename = os.path.join(directory,&#39;new_big_{}.csv.bz2&#39;)
        if atoms is not None and len(atoms):
                atoms = atoms.sort_values([&#34;molecule_name&#34;,&#39;atom_index&#39;])
                for i in range(4):
                        atoms[&#34;top_bond_{}&#34;.format(i)] = [x[i] if len(x)&gt;i else 0.0 for x in atoms[&#34;top_bond&#34;].values]
                for i in [&#34;x&#34;,&#34;y&#34;,&#34;z&#34;]:
                        atoms[i] = atoms[i].values.round(10)
                renames = {k:k[:-1] for k in atoms.columns if k[-1]==&#39;s&#39;}
                renames.update({&#39;long_symbols&#39;:&#39;labeled_atom&#39;})
                atoms = atoms.rename(columns=renames)
                atoms.to_csv(filename.format(&#39;structures&#39;),index=False,columns=
                        &#39;molecule_name,atom_index,atom,x,y,z,labeled_atom,angle,top_bond_0,top_bond_1,top_bond_2,top_bond_3,sublabel_atom,charge,spin,heavyvalence,heterovalence,valence,hyb_type&#39;.split(&#39;,&#39;))
        if bonds is not None and len(bonds):
                bonds = bonds.reset_index()
                bond_columns = &#39;id,molecule_name,atom_index_0,atom_index_1,type,scalar_coupling_constant,labeled_type,sublabel_type,bond_order,predict&#39;.split(&#39;,&#39;)
                if &#39;scalar_coupling_constant&#39; not in bonds.columns:
                        bond_columns = [x for x in bond_columns if x!=&#39;scalar_coupling_constant&#39;]
                bonds = bonds.sort_values([&#34;predict&#34;,&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;],
                                                                  ascending=[False,True,True,True])
                bonds.to_csv(filename.format(label),index=False,columns=bond_columns)
        if triplets is not None and len(triplets):
                triplets = triplets.sort_values([&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;])
                triplets.to_csv(filename.format(label+&#39;_triplets&#39;),index=False,columns=
                        &#39;molecule_name,atom_index_0,atom_index_1,atom_index_2,label,sublabel,angle&#39;.split(&#39;,&#39;))
        if quadruplets is not None and len(quadruplets):
                quadruplets = quadruplets.sort_values([&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,
                                                                                           &#39;atom_index_2&#39;,&#39;atom_index_3&#39;])
                quadruplets.to_csv(filename.format(label+&#39;_quadruplets&#39;),index=False,columns=
                        &#39;molecule_name,atom_index_0,atom_index_1,atom_index_2,atom_index_3,label,sublabel,sublabel2,sublabel3,sublabel4,angle&#39;.split(&#39;,&#39;))


def _create_embedding(series):
        &#34;&#34;&#34;Create a one-hot encoding embedding.

        Args:
                series: A DataFrame series (column).

        Returns:
                dict: Mapping of the entries (or &#34;&lt;None&gt;&#34;) to the index number.

        &#34;&#34;&#34;
        types = sorted(series.unique().tolist())
        assert &#34;&lt;None&gt;&#34; not in types
        emb_index = dict(zip([&#34;&lt;None&gt;&#34;] + types , range(len(types)+1)))
        return emb_index


def add_embedding(atoms,bonds,triplets,quadruplets,embeddings=None):
        &#34;&#34;&#34;Add embedding indices to the dataframes.

        Args:
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quadruplets: Pandas dataframe created by :func:`make_quadruplets`.
                embeddings (dict or None): If None, we create a new embedding (e.g. train data), otherwise we use the given embeddigns thar are output by :func:`add_embedding` (e.g. test data).

        Returns:
                dict: The embedding dictionary that can be passed to this function for using the same embedding on a new dataset.

        &#34;&#34;&#34;
        # Add the embedding info to the dataframes.
        atoms[&#34;type_0&#34;] = atoms[&#34;atom&#34;]
        atoms[&#34;type_1&#34;] = atoms[&#34;labeled_atom&#34;].apply(lambda x : x[:5])
        atoms[&#34;type_2&#34;] = atoms[&#34;labeled_atom&#34;]
        bonds[&#34;type_0&#34;] = bonds[&#34;type&#34;]
        bonds[&#34;type_1&#34;] = bonds[&#34;labeled_type&#34;]
        bonds[&#34;type_2&#34;] = bonds[&#34;sublabel_type&#34;]
        triplets[&#34;type_0&#34;] = triplets[&#34;label&#34;].apply(lambda x : x[0] + x[5] + x[10])
        triplets[&#34;type_1&#34;] = triplets[&#34;label&#34;]
        quadruplets[&#34;type_0&#34;] = quadruplets[&#34;label&#34;]
        if embeddings is None:
                embeddings = {}
                embeddings.update({(&#39;atom&#39;,t):_create_embedding(atoms[&#34;type_&#34; + str(t)]) for t in range(3)})
                embeddings.update({(&#39;bond&#39;,t):_create_embedding(bonds[&#34;type_&#34; + str(t)]) for t in range(3)})
                embeddings.update({(&#39;triplet&#39;,t):_create_embedding(triplets[&#34;type_&#34; + str(t)]) for t in range(2)})
                embeddings.update({(&#39;quadruplet&#39;,t):_create_embedding(quadruplets[&#34;type_&#34; + str(t)]) for t in range(1)})
        for t in range(3):
                atoms[&#34;type_index_&#34; + str(t)] = atoms[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;atom&#39;,t)][x])
        for t in range(3):
                bonds[&#34;type_index_&#34; + str(t)] = bonds[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;bond&#39;,t)][x])
        for t in range(2):
                triplets[&#34;type_index_&#34; + str(t)] = triplets[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;triplet&#39;,t)][x])
        for t in range(1):
                quadruplets[&#34;type_index_&#34; + str(t)] = quadruplets[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;quadruplet&#39;,t)][x])
        return embeddings


def get_scaling(bonds_train):
        &#34;&#34;&#34;Get the mean/std scaling factors for each ``labeled_type``.

        Args:
                bonds_train: The training data that we can use to set the values.

        Returns:
                tuple: Mean and std dicts, mapping labeled_type to scalar_coupling_constant mean/std.

        &#34;&#34;&#34;
        # Get the mean/std scaling factors
        means = bonds_train.groupby(&#34;labeled_type&#34;).mean()[&#34;scalar_coupling_constant&#34;].to_dict()
        stds = bonds_train.groupby(&#34;labeled_type&#34;).std()[&#34;scalar_coupling_constant&#34;].to_dict()
        return means,stds


def add_scaling(bonds,means,stds):
        &#34;&#34;&#34;Add the scaling information to the bonds dataframe.

        Args:
                bonds (pd.DataFrame): The dataframe of the bonds, after :func:`enhance_bonds`.
                means (dict): Output of :func:`get_scaling`.
                stds (dict): Output of :func:`get_scaling`.

        Returns:
                pd.DataFrame: Same dataframe, with added columns.

        &#34;&#34;&#34;
        # Add mean/std scaling factors to bonds dataframe
        bonds[&#34;sc_mean&#34;] = bonds[&#34;labeled_type&#34;].apply(lambda x : means[x])
        bonds[&#34;sc_std&#34;] = bonds[&#34;labeled_type&#34;].apply(lambda x : stds[x])
        if &#34;scalar_coupling_constant&#34; in bonds.columns:
                bonds[&#34;sc_scaled&#34;] = (bonds[&#34;scalar_coupling_constant&#34;] - bonds[&#34;sc_mean&#34;]) / bonds[&#34;sc_std&#34;]
        return bonds


def create_dataset(atoms, bonds, triplets, quads, labeled = True, max_count = 10**10):
        &#34;&#34;&#34;Create the python loaders, which we can pkl to a file for batching.

        Args:
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quads: Pandas dataframe created by :func:`make_quadruplets`.
                labeled (bool): Whether this is train data, labeled with the y value.
                max_count (int): Maximum number of entries; useful for testing.

        Returns:
                tuple: With the following entries

                        * x_index: (M,) Index of the molecule.
                        * x_atom: (M,N,3) Atom type index.
                        * x_atom_pos: (M,N,5) Atom position (3), closest-atom angle (1), and partial charge (1).
                        * x_bond: (M,B,5) Bond type index (3), Atom index (2) corresponding to the bond.
                        * x_bond_dist: (M,B) Distance of the bond.
                        * x_triplet: (N,P,7): Triplet type (2), Atom index (3), Bond index (2) corresponding to the triplet.
                        * x_triplet_angle: (N,P) Triplet angle.
                        * x_quad: (N,Q,10) Quadruplet type (1), Atom index (4), Bond index (3), and triplet index (2) corresponding to the quadruplet.
                        * x_quad_angle: (N,Q) Quadruplet dihedral angle.
                        * y_bond_scalar_coupling: (N,M,4) of the scalar coupling constant, type mean, type std, and whether it should be predicted.

        &#34;&#34;&#34;
        import torch
        from tqdm import tqdm
        # create mapping from molecule names to indices
        mol_unique = sorted(bonds[&#34;molecule_name&#34;].unique().tolist())
        index = dict(zip(mol_unique, range(len(mol_unique))))
        atoms = atoms.set_index(&#34;molecule_name&#34;)
        bonds = bonds.set_index(&#34;molecule_name&#34;)
        triplets = triplets.set_index(&#34;molecule_name&#34;)
        quads = quads.set_index(&#34;molecule_name&#34;)
        quad_mols = set(quads.index)

        max_count = M = min(max_count, len(index))

        x_index = torch.arange(M, dtype=torch.long)
        x_atom = torch.zeros(M, MAX_ATOM_COUNT, 3, dtype=torch.long)
        x_atom_pos = torch.zeros(M, MAX_ATOM_COUNT, 5)
        x_bond = torch.zeros(M, MAX_BOND_COUNT, 5, dtype=torch.long)
        x_bond_dist = torch.zeros(M, MAX_BOND_COUNT)
        x_triplet = torch.zeros(M, MAX_TRIPLET_COUNT, 7, dtype=torch.long)
        x_triplet_angle = torch.zeros(M, MAX_TRIPLET_COUNT)
        x_quad = torch.zeros(M, MAX_QUAD_COUNT, 10, dtype=torch.long)
        x_quad_angle = torch.zeros(M, MAX_QUAD_COUNT)

        y_bond_scalar_coupling = torch.zeros(M, MAX_BOND_COUNT, 4)

        for k,i in tqdm(index.items()):
                if i &gt;= M:
                        break
                mol_atoms = atoms.loc[[k]]
                mol_bonds = bonds.loc[[k]]
                mol_real_bonds = mol_bonds[(mol_bonds[&#34;predict&#34;]==1) | (mol_bonds[&#34;bond_order&#34;]&gt;0)]
                mol_fake_bonds = mol_bonds[(mol_bonds[&#34;predict&#34;]==0) &amp; (mol_bonds[&#34;bond_order&#34;]==0)]
                mol_triplets = triplets.loc[[k]]

                n = mol_atoms.shape[0]
                m = mol_bonds.shape[0]
                mr = mol_real_bonds.shape[0]
                mf = mol_fake_bonds.shape[0]
                p = mol_triplets.shape[0]
                assert mr + mf == m, &#34;Real + fake bonds != number of bonds?&#34;
                assert mr &lt; MAX_BOND_COUNT, &#34;The number of real bonds is SMALLER than the MAX_BOND_COUNT&#34;

                # STEP 1: Atoms
                for t in range(3):
                        x_atom[i,:n,t] = torch.tensor(mol_atoms[&#34;type_index_&#34; + str(t)].values)
                x_atom_pos[i,:n,:3] = torch.tensor(mol_atoms[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]].values)
                x_atom_pos[i,:n,3] = torch.tensor(mol_atoms[&#34;angle&#34;].values)
                x_atom_pos[i,:n,4] = torch.tensor(mol_atoms[&#34;charge&#34;].values)

                # STEP 2: Real bonds
                for t in range(3):
                        x_bond[i,:mr,t] = torch.tensor(mol_real_bonds[&#34;type_index_&#34; + str(t)].values)
                x_bond[i,:mr,3] = torch.tensor(mol_real_bonds[&#34;atom_index_0&#34;].values)
                x_bond[i,:mr,4] = torch.tensor(mol_real_bonds[&#34;atom_index_1&#34;].values)

                idx1 = torch.tensor(mol_real_bonds[&#34;atom_index_0&#34;].values)
                idx2 = torch.tensor(mol_real_bonds[&#34;atom_index_1&#34;].values)
                x_bond_dist[i,:mr] = ((x_atom_pos[i,idx1,:3] - x_atom_pos[i,idx2,:3])**2).sum(1)

                if mf &gt; 0:
                        # STEP 3: Fake bonds
                        fidx1 = torch.tensor(mol_fake_bonds[&#34;atom_index_0&#34;].values)
                        fidx2 = torch.tensor(mol_fake_bonds[&#34;atom_index_1&#34;].values)
                        fdists = ((x_atom_pos[i,fidx1,:3] - x_atom_pos[i,fidx2,:3])**2).sum(1)   # Length mf
                        argsort_fdists = torch.argsort(fdists)
                        top_count = min(MAX_BOND_COUNT - mr, mf)

                        for t in range(3):
                                x_bond[i,mr:mr+top_count,t] = torch.tensor(mol_fake_bonds[&#34;type_index_&#34; + str(t)].values)[argsort_fdists][:top_count]
                        x_bond[i,mr:mr+top_count,3] = torch.tensor(mol_fake_bonds[&#34;atom_index_0&#34;].values)[argsort_fdists][:top_count]
                        x_bond[i,mr:mr+top_count,4] = torch.tensor(mol_fake_bonds[&#34;atom_index_1&#34;].values)[argsort_fdists][:top_count]
                        x_bond_dist[i,mr:mr+top_count] = fdists[argsort_fdists][:top_count]

                # STEP 4: Triplets
                for t in range(2):
                        x_triplet[i,:p,t] = torch.tensor(mol_triplets[&#34;type_index_&#34; + str(t)].values)
                x_triplet[i,:p,2] = torch.tensor(mol_triplets[&#34;atom_index_0&#34;].values)
                x_triplet[i,:p,3] = torch.tensor(mol_triplets[&#34;atom_index_1&#34;].values)
                x_triplet[i,:p,4] = torch.tensor(mol_triplets[&#34;atom_index_2&#34;].values)

                x_triplet_angle[i,:p] = torch.tensor(mol_triplets[&#34;angle&#34;].values)
                lookup = dict(zip(mol_real_bonds[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; + mol_real_bonds[&#34;atom_index_1&#34;].apply(str),
                                                  range(mol_real_bonds.shape[0])))
                lookup.update(dict(zip(mol_real_bonds[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; + mol_real_bonds[&#34;atom_index_0&#34;].apply(str),
                                                   range(mol_real_bonds.shape[0]))))

                b_idx1 = (mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                  mol_triplets[&#34;atom_index_1&#34;].apply(str)).apply(lambda x : lookup[x])
                b_idx2 = (mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                  mol_triplets[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup[x])

                x_triplet[i,:p,5] = torch.tensor(b_idx1.values)
                x_triplet[i,:p,5] = torch.tensor(b_idx2.values)

                # STEP 5: Quadruplets
                if k in quad_mols:
                        mol_quads = quads.loc[[k]]
                        q = mol_quads.shape[0]

                        x_quad[i,:q,0] = torch.tensor(mol_quads[&#34;type_index_0&#34;].values)
                        x_quad[i,:q,1] = torch.tensor(mol_quads[&#34;atom_index_0&#34;].values)
                        x_quad[i,:q,2] = torch.tensor(mol_quads[&#34;atom_index_1&#34;].values)
                        x_quad[i,:q,3] = torch.tensor(mol_quads[&#34;atom_index_2&#34;].values)
                        x_quad[i,:q,4] = torch.tensor(mol_quads[&#34;atom_index_3&#34;].values)

                        x_quad_angle[i,:q] = torch.tensor(mol_quads[&#34;angle&#34;].values)
                        # Triplet convention is 1-0-2, so only 1/2 are exchangeable
                        # Quadruplet convention is 2-0-1-3
                        lookup3 = dict(zip(mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_2&#34;].apply(str),
                                                          range(mol_triplets.shape[0])))
                        lookup3.update(dict(zip(mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_2&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_1&#34;].apply(str),
                                                          range(mol_triplets.shape[0]))))
                        b_idx1 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_1&#34;].apply(str)).apply(lambda x : lookup[x])
                        b_idx2 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup[x])
                        b_idx3 = (mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_3&#34;].apply(str)).apply(lambda x : lookup[x])
                        t_idx1 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup3[x])
                        t_idx2 = (mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_3&#34;].apply(str)).apply(lambda x : lookup3[x])

                        x_quad[i,:q,5] = torch.tensor(b_idx1.values)
                        x_quad[i,:q,6] = torch.tensor(b_idx2.values)
                        x_quad[i,:q,7] = torch.tensor(b_idx3.values)
                        x_quad[i,:q,8] = torch.tensor(t_idx1.values)
                        x_quad[i,:q,9] = torch.tensor(t_idx2.values)

                        x_quad_angle[i,:q] = torch.tensor(mol_quads[&#34;angle&#34;].values)

                if labeled:
                        y_bond_scalar_coupling[i,:mr, 0] = torch.tensor(mol_real_bonds[&#34;scalar_coupling_constant&#34;].values)
                else:
                        y_bond_scalar_coupling[i,:mr, 0] = torch.tensor(mol_real_bonds[&#34;id&#34;].values)
                y_bond_scalar_coupling[i,:mr, 1] = torch.tensor(mol_real_bonds[&#34;sc_mean&#34;].values)
                y_bond_scalar_coupling[i,:mr, 2] = torch.tensor(mol_real_bonds[&#34;sc_std&#34;].values)
                y_bond_scalar_coupling[i,:mr, 3] = torch.tensor(mol_real_bonds[&#34;predict&#34;].values).float()  # binary tensor (1s to be predicted)

        return x_index, x_atom, x_atom_pos, x_bond, x_bond_dist, x_triplet, x_triplet_angle, x_quad, x_quad_angle, y_bond_scalar_coupling</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_all_pairs"><code class="name flex">
<span>def <span class="ident">add_all_pairs</span></span>(<span>bond_dataframe, structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Add all pairs of atoms, including those without coupling and without chemical bonds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bond_dataframe</code></strong></dt>
<dd>Pandas dataframe read from train.csv or test.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code>enhance_bonds()</code></a>.</dd>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code>enhance_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pandas.DataFrame: New dataframe, with new bonds added.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_all_pairs(bond_dataframe,structure_dict):
        &#34;&#34;&#34;Add all pairs of atoms, including those without coupling and without chemical bonds.

        Args:
                bond_dataframe: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with new bonds added.

        &#34;&#34;&#34;
        # NOTE: The convention for id used to be very large numbers for new bonds; now it is negative.
        iadd = -1
        new_data = collections.defaultdict(list)
        for molecule_name in bond_dataframe[&#34;molecule_name&#34;].unique():
                n_atom = len(structure_dict[molecule_name][&#34;symbols&#34;])
                # for backwards compatibility, this is iatom1,iatom0. See make_new_csv.py, write_pairs.
                for iatom1,iatom0 in itertools.combinations(range(n_atom),r=2):
                        if &#39;predict&#39; not in structure_dict[molecule_name]:
                                raise KeyError(&#39;{} has no &#34;predict&#34; value&#39;.format(molecule_name))
                        if structure_dict[molecule_name][&#39;predict&#39;][iatom0,iatom1]:
                                continue  # already got it
                        symbols = [structure_dict[molecule_name][&#39;symbols&#39;][i] for i in [iatom0,iatom1]]
                        bond_order = structure_dict[molecule_name][&#39;bond_orders&#39;][iatom0,iatom1]
                        nottype = &#39;-&#39;.join(sorted(symbols)) + &#39;_&#39; + str(bond_order)

                        row = {&#39;id&#39;:iadd,&#39;molecule_name&#39;:molecule_name,&#39;atom_index_0&#39;:iatom0,&#39;atom_index_1&#39;:iatom1,
                                   &#39;type&#39;:nottype,&#39;labeled_type&#39;:nottype,&#39;sublabel_type&#39;:nottype,
                                   &#39;bond_order&#39;: bond_order,
                                   &#39;predict&#39;:0}
                        if &#39;scalar_coupling_constant&#39; in bond_dataframe:
                                row[&#39;scalar_coupling_constant&#39;] = 0.
                        for k,v in row.items():
                                new_data[k].append(v)
                        iadd -= 1
        new_data = pd.DataFrame(new_data)
        if bond_dataframe.index.name!=&#39;id&#39;:
                bond_dataframe = bond_dataframe.set_index(&#39;id&#39;)
        new_data.set_index(&#39;id&#39;,inplace=True)
        all_data = bond_dataframe.append(new_data,verify_integrity=True,sort=False)
        return all_data</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_embedding"><code class="name flex">
<span>def <span class="ident">add_embedding</span></span>(<span>atoms, bonds, triplets, quadruplets, embeddings=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add embedding indices to the dataframes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atoms</code></strong></dt>
<dd>Pandas dataframe read from structures.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms"><code>enhance_atoms()</code></a>.</dd>
<dt><strong><code>bonds</code></strong></dt>
<dd>Pandas dataframe read from train.csv or test.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code>enhance_bonds()</code></a>.</dd>
<dt><strong><code>triplets</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets"><code>make_triplets()</code></a>.</dd>
<dt><strong><code>quadruplets</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets"><code>make_quadruplets()</code></a>.</dd>
<dt><strong><code>embeddings</code></strong> :&ensp;<code>dict</code> or <code>None</code></dt>
<dd>If None, we create a new embedding (e.g. train data), otherwise we use the given embeddigns thar are output by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_embedding" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_embedding"><code>add_embedding()</code></a> (e.g. test data).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>The embedding dictionary that can be passed to this function for using the same embedding on a new dataset.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_embedding(atoms,bonds,triplets,quadruplets,embeddings=None):
        &#34;&#34;&#34;Add embedding indices to the dataframes.

        Args:
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quadruplets: Pandas dataframe created by :func:`make_quadruplets`.
                embeddings (dict or None): If None, we create a new embedding (e.g. train data), otherwise we use the given embeddigns thar are output by :func:`add_embedding` (e.g. test data).

        Returns:
                dict: The embedding dictionary that can be passed to this function for using the same embedding on a new dataset.

        &#34;&#34;&#34;
        # Add the embedding info to the dataframes.
        atoms[&#34;type_0&#34;] = atoms[&#34;atom&#34;]
        atoms[&#34;type_1&#34;] = atoms[&#34;labeled_atom&#34;].apply(lambda x : x[:5])
        atoms[&#34;type_2&#34;] = atoms[&#34;labeled_atom&#34;]
        bonds[&#34;type_0&#34;] = bonds[&#34;type&#34;]
        bonds[&#34;type_1&#34;] = bonds[&#34;labeled_type&#34;]
        bonds[&#34;type_2&#34;] = bonds[&#34;sublabel_type&#34;]
        triplets[&#34;type_0&#34;] = triplets[&#34;label&#34;].apply(lambda x : x[0] + x[5] + x[10])
        triplets[&#34;type_1&#34;] = triplets[&#34;label&#34;]
        quadruplets[&#34;type_0&#34;] = quadruplets[&#34;label&#34;]
        if embeddings is None:
                embeddings = {}
                embeddings.update({(&#39;atom&#39;,t):_create_embedding(atoms[&#34;type_&#34; + str(t)]) for t in range(3)})
                embeddings.update({(&#39;bond&#39;,t):_create_embedding(bonds[&#34;type_&#34; + str(t)]) for t in range(3)})
                embeddings.update({(&#39;triplet&#39;,t):_create_embedding(triplets[&#34;type_&#34; + str(t)]) for t in range(2)})
                embeddings.update({(&#39;quadruplet&#39;,t):_create_embedding(quadruplets[&#34;type_&#34; + str(t)]) for t in range(1)})
        for t in range(3):
                atoms[&#34;type_index_&#34; + str(t)] = atoms[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;atom&#39;,t)][x])
        for t in range(3):
                bonds[&#34;type_index_&#34; + str(t)] = bonds[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;bond&#39;,t)][x])
        for t in range(2):
                triplets[&#34;type_index_&#34; + str(t)] = triplets[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;triplet&#39;,t)][x])
        for t in range(1):
                quadruplets[&#34;type_index_&#34; + str(t)] = quadruplets[&#34;type_&#34; + str(t)].apply(lambda x : embeddings[(&#39;quadruplet&#39;,t)][x])
        return embeddings</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_scaling"><code class="name flex">
<span>def <span class="ident">add_scaling</span></span>(<span>bonds, means, stds)</span>
</code></dt>
<dd>
<section class="desc"><p>Add the scaling information to the bonds dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bonds</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The dataframe of the bonds, after :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code>enhance_bonds()</code></a>.</dd>
<dt><strong><code>means</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling"><code>get_scaling()</code></a>.</dd>
<dt><strong><code>stds</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling"><code>get_scaling()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pd.DataFrame: Same dataframe, with added columns.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_scaling(bonds,means,stds):
        &#34;&#34;&#34;Add the scaling information to the bonds dataframe.

        Args:
                bonds (pd.DataFrame): The dataframe of the bonds, after :func:`enhance_bonds`.
                means (dict): Output of :func:`get_scaling`.
                stds (dict): Output of :func:`get_scaling`.

        Returns:
                pd.DataFrame: Same dataframe, with added columns.

        &#34;&#34;&#34;
        # Add mean/std scaling factors to bonds dataframe
        bonds[&#34;sc_mean&#34;] = bonds[&#34;labeled_type&#34;].apply(lambda x : means[x])
        bonds[&#34;sc_std&#34;] = bonds[&#34;labeled_type&#34;].apply(lambda x : stds[x])
        if &#34;scalar_coupling_constant&#34; in bonds.columns:
                bonds[&#34;sc_scaled&#34;] = (bonds[&#34;scalar_coupling_constant&#34;] - bonds[&#34;sc_mean&#34;]) / bonds[&#34;sc_std&#34;]
        return bonds</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.create_dataset"><code class="name flex">
<span>def <span class="ident">create_dataset</span></span>(<span>atoms, bonds, triplets, quads, labeled=True, max_count=10000000000)</span>
</code></dt>
<dd>
<section class="desc"><p>Create the python loaders, which we can pkl to a file for batching.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atoms</code></strong></dt>
<dd>Pandas dataframe read from structures.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms"><code>enhance_atoms()</code></a>.</dd>
<dt><strong><code>bonds</code></strong></dt>
<dd>Pandas dataframe read from train.csv or test.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code>enhance_bonds()</code></a>.</dd>
<dt><strong><code>triplets</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets"><code>make_triplets()</code></a>.</dd>
<dt><strong><code>quads</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets"><code>make_quadruplets()</code></a>.</dd>
<dt><strong><code>labeled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether this is train data, labeled with the y value.</dd>
<dt><strong><code>max_count</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum number of entries; useful for testing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tuple</code></strong></dt>
<dd>With the following entries<pre><code>* x_index: (M,) Index of the molecule.
* x_atom: (M,N,3) Atom type index.
* x_atom_pos: (M,N,5) Atom position (3), closest-atom angle (1), and partial charge (1).
* x_bond: (M,B,5) Bond type index (3), Atom index (2) corresponding to the bond.
* x_bond_dist: (M,B) Distance of the bond.
* x_triplet: (N,P,7): Triplet type (2), Atom index (3), Bond index (2) corresponding to the triplet.
* x_triplet_angle: (N,P) Triplet angle.
* x_quad: (N,Q,10) Quadruplet type (1), Atom index (4), Bond index (3), and triplet index (2) corresponding to the quadruplet.
* x_quad_angle: (N,Q) Quadruplet dihedral angle.
* y_bond_scalar_coupling: (N,M,4) of the scalar coupling constant, type mean, type std, and whether it should be predicted.
</code></pre>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_dataset(atoms, bonds, triplets, quads, labeled = True, max_count = 10**10):
        &#34;&#34;&#34;Create the python loaders, which we can pkl to a file for batching.

        Args:
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quads: Pandas dataframe created by :func:`make_quadruplets`.
                labeled (bool): Whether this is train data, labeled with the y value.
                max_count (int): Maximum number of entries; useful for testing.

        Returns:
                tuple: With the following entries

                        * x_index: (M,) Index of the molecule.
                        * x_atom: (M,N,3) Atom type index.
                        * x_atom_pos: (M,N,5) Atom position (3), closest-atom angle (1), and partial charge (1).
                        * x_bond: (M,B,5) Bond type index (3), Atom index (2) corresponding to the bond.
                        * x_bond_dist: (M,B) Distance of the bond.
                        * x_triplet: (N,P,7): Triplet type (2), Atom index (3), Bond index (2) corresponding to the triplet.
                        * x_triplet_angle: (N,P) Triplet angle.
                        * x_quad: (N,Q,10) Quadruplet type (1), Atom index (4), Bond index (3), and triplet index (2) corresponding to the quadruplet.
                        * x_quad_angle: (N,Q) Quadruplet dihedral angle.
                        * y_bond_scalar_coupling: (N,M,4) of the scalar coupling constant, type mean, type std, and whether it should be predicted.

        &#34;&#34;&#34;
        import torch
        from tqdm import tqdm
        # create mapping from molecule names to indices
        mol_unique = sorted(bonds[&#34;molecule_name&#34;].unique().tolist())
        index = dict(zip(mol_unique, range(len(mol_unique))))
        atoms = atoms.set_index(&#34;molecule_name&#34;)
        bonds = bonds.set_index(&#34;molecule_name&#34;)
        triplets = triplets.set_index(&#34;molecule_name&#34;)
        quads = quads.set_index(&#34;molecule_name&#34;)
        quad_mols = set(quads.index)

        max_count = M = min(max_count, len(index))

        x_index = torch.arange(M, dtype=torch.long)
        x_atom = torch.zeros(M, MAX_ATOM_COUNT, 3, dtype=torch.long)
        x_atom_pos = torch.zeros(M, MAX_ATOM_COUNT, 5)
        x_bond = torch.zeros(M, MAX_BOND_COUNT, 5, dtype=torch.long)
        x_bond_dist = torch.zeros(M, MAX_BOND_COUNT)
        x_triplet = torch.zeros(M, MAX_TRIPLET_COUNT, 7, dtype=torch.long)
        x_triplet_angle = torch.zeros(M, MAX_TRIPLET_COUNT)
        x_quad = torch.zeros(M, MAX_QUAD_COUNT, 10, dtype=torch.long)
        x_quad_angle = torch.zeros(M, MAX_QUAD_COUNT)

        y_bond_scalar_coupling = torch.zeros(M, MAX_BOND_COUNT, 4)

        for k,i in tqdm(index.items()):
                if i &gt;= M:
                        break
                mol_atoms = atoms.loc[[k]]
                mol_bonds = bonds.loc[[k]]
                mol_real_bonds = mol_bonds[(mol_bonds[&#34;predict&#34;]==1) | (mol_bonds[&#34;bond_order&#34;]&gt;0)]
                mol_fake_bonds = mol_bonds[(mol_bonds[&#34;predict&#34;]==0) &amp; (mol_bonds[&#34;bond_order&#34;]==0)]
                mol_triplets = triplets.loc[[k]]

                n = mol_atoms.shape[0]
                m = mol_bonds.shape[0]
                mr = mol_real_bonds.shape[0]
                mf = mol_fake_bonds.shape[0]
                p = mol_triplets.shape[0]
                assert mr + mf == m, &#34;Real + fake bonds != number of bonds?&#34;
                assert mr &lt; MAX_BOND_COUNT, &#34;The number of real bonds is SMALLER than the MAX_BOND_COUNT&#34;

                # STEP 1: Atoms
                for t in range(3):
                        x_atom[i,:n,t] = torch.tensor(mol_atoms[&#34;type_index_&#34; + str(t)].values)
                x_atom_pos[i,:n,:3] = torch.tensor(mol_atoms[[&#34;x&#34;, &#34;y&#34;, &#34;z&#34;]].values)
                x_atom_pos[i,:n,3] = torch.tensor(mol_atoms[&#34;angle&#34;].values)
                x_atom_pos[i,:n,4] = torch.tensor(mol_atoms[&#34;charge&#34;].values)

                # STEP 2: Real bonds
                for t in range(3):
                        x_bond[i,:mr,t] = torch.tensor(mol_real_bonds[&#34;type_index_&#34; + str(t)].values)
                x_bond[i,:mr,3] = torch.tensor(mol_real_bonds[&#34;atom_index_0&#34;].values)
                x_bond[i,:mr,4] = torch.tensor(mol_real_bonds[&#34;atom_index_1&#34;].values)

                idx1 = torch.tensor(mol_real_bonds[&#34;atom_index_0&#34;].values)
                idx2 = torch.tensor(mol_real_bonds[&#34;atom_index_1&#34;].values)
                x_bond_dist[i,:mr] = ((x_atom_pos[i,idx1,:3] - x_atom_pos[i,idx2,:3])**2).sum(1)

                if mf &gt; 0:
                        # STEP 3: Fake bonds
                        fidx1 = torch.tensor(mol_fake_bonds[&#34;atom_index_0&#34;].values)
                        fidx2 = torch.tensor(mol_fake_bonds[&#34;atom_index_1&#34;].values)
                        fdists = ((x_atom_pos[i,fidx1,:3] - x_atom_pos[i,fidx2,:3])**2).sum(1)   # Length mf
                        argsort_fdists = torch.argsort(fdists)
                        top_count = min(MAX_BOND_COUNT - mr, mf)

                        for t in range(3):
                                x_bond[i,mr:mr+top_count,t] = torch.tensor(mol_fake_bonds[&#34;type_index_&#34; + str(t)].values)[argsort_fdists][:top_count]
                        x_bond[i,mr:mr+top_count,3] = torch.tensor(mol_fake_bonds[&#34;atom_index_0&#34;].values)[argsort_fdists][:top_count]
                        x_bond[i,mr:mr+top_count,4] = torch.tensor(mol_fake_bonds[&#34;atom_index_1&#34;].values)[argsort_fdists][:top_count]
                        x_bond_dist[i,mr:mr+top_count] = fdists[argsort_fdists][:top_count]

                # STEP 4: Triplets
                for t in range(2):
                        x_triplet[i,:p,t] = torch.tensor(mol_triplets[&#34;type_index_&#34; + str(t)].values)
                x_triplet[i,:p,2] = torch.tensor(mol_triplets[&#34;atom_index_0&#34;].values)
                x_triplet[i,:p,3] = torch.tensor(mol_triplets[&#34;atom_index_1&#34;].values)
                x_triplet[i,:p,4] = torch.tensor(mol_triplets[&#34;atom_index_2&#34;].values)

                x_triplet_angle[i,:p] = torch.tensor(mol_triplets[&#34;angle&#34;].values)
                lookup = dict(zip(mol_real_bonds[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; + mol_real_bonds[&#34;atom_index_1&#34;].apply(str),
                                                  range(mol_real_bonds.shape[0])))
                lookup.update(dict(zip(mol_real_bonds[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; + mol_real_bonds[&#34;atom_index_0&#34;].apply(str),
                                                   range(mol_real_bonds.shape[0]))))

                b_idx1 = (mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                  mol_triplets[&#34;atom_index_1&#34;].apply(str)).apply(lambda x : lookup[x])
                b_idx2 = (mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                  mol_triplets[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup[x])

                x_triplet[i,:p,5] = torch.tensor(b_idx1.values)
                x_triplet[i,:p,5] = torch.tensor(b_idx2.values)

                # STEP 5: Quadruplets
                if k in quad_mols:
                        mol_quads = quads.loc[[k]]
                        q = mol_quads.shape[0]

                        x_quad[i,:q,0] = torch.tensor(mol_quads[&#34;type_index_0&#34;].values)
                        x_quad[i,:q,1] = torch.tensor(mol_quads[&#34;atom_index_0&#34;].values)
                        x_quad[i,:q,2] = torch.tensor(mol_quads[&#34;atom_index_1&#34;].values)
                        x_quad[i,:q,3] = torch.tensor(mol_quads[&#34;atom_index_2&#34;].values)
                        x_quad[i,:q,4] = torch.tensor(mol_quads[&#34;atom_index_3&#34;].values)

                        x_quad_angle[i,:q] = torch.tensor(mol_quads[&#34;angle&#34;].values)
                        # Triplet convention is 1-0-2, so only 1/2 are exchangeable
                        # Quadruplet convention is 2-0-1-3
                        lookup3 = dict(zip(mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_2&#34;].apply(str),
                                                          range(mol_triplets.shape[0])))
                        lookup3.update(dict(zip(mol_triplets[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_2&#34;].apply(str) + &#34;_&#34; +
                                                           mol_triplets[&#34;atom_index_1&#34;].apply(str),
                                                          range(mol_triplets.shape[0]))))
                        b_idx1 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_1&#34;].apply(str)).apply(lambda x : lookup[x])
                        b_idx2 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup[x])
                        b_idx3 = (mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_3&#34;].apply(str)).apply(lambda x : lookup[x])
                        t_idx1 = (mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_2&#34;].apply(str)).apply(lambda x : lookup3[x])
                        t_idx2 = (mol_quads[&#34;atom_index_1&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_0&#34;].apply(str) + &#34;_&#34; +
                                          mol_quads[&#34;atom_index_3&#34;].apply(str)).apply(lambda x : lookup3[x])

                        x_quad[i,:q,5] = torch.tensor(b_idx1.values)
                        x_quad[i,:q,6] = torch.tensor(b_idx2.values)
                        x_quad[i,:q,7] = torch.tensor(b_idx3.values)
                        x_quad[i,:q,8] = torch.tensor(t_idx1.values)
                        x_quad[i,:q,9] = torch.tensor(t_idx2.values)

                        x_quad_angle[i,:q] = torch.tensor(mol_quads[&#34;angle&#34;].values)

                if labeled:
                        y_bond_scalar_coupling[i,:mr, 0] = torch.tensor(mol_real_bonds[&#34;scalar_coupling_constant&#34;].values)
                else:
                        y_bond_scalar_coupling[i,:mr, 0] = torch.tensor(mol_real_bonds[&#34;id&#34;].values)
                y_bond_scalar_coupling[i,:mr, 1] = torch.tensor(mol_real_bonds[&#34;sc_mean&#34;].values)
                y_bond_scalar_coupling[i,:mr, 2] = torch.tensor(mol_real_bonds[&#34;sc_std&#34;].values)
                y_bond_scalar_coupling[i,:mr, 3] = torch.tensor(mol_real_bonds[&#34;predict&#34;].values).float()  # binary tensor (1s to be predicted)

        return x_index, x_atom, x_atom_pos, x_bond, x_bond_dist, x_triplet, x_triplet_angle, x_quad, x_quad_angle, y_bond_scalar_coupling</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms"><code class="name flex">
<span>def <span class="ident">enhance_atoms</span></span>(<span>atoms_dataframe, structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Enhance the atoms dataframe by including derived information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atoms_dataframe</code></strong></dt>
<dd>Pandas dataframe read from structures.csv.</dd>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code>enhance_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pandas.DataFrame: Same dataframe, modified in-place, with derived information added.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enhance_atoms(atoms_dataframe,structure_dict):
        &#34;&#34;&#34;Enhance the atoms dataframe by including derived information.

        Args:
                atoms_dataframe: Pandas dataframe read from structures.csv.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: Same dataframe, modified in-place, with derived information added.

        &#34;&#34;&#34;
        assert int(atoms_dataframe.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_ATOM_COUNT
        for key in [&#39;distances&#39;,&#39;angle&#39;, &#39;bond_orders&#39;, &#39;top_bonds&#39;, &#39;bond_ids&#39;, &#39;long_symbols&#39;,&#39;sublabel_atom&#39;,
                                &#39;charges&#39;, &#39;spins&#39;, &#39;heavyvalences&#39;, &#39;heterovalences&#39;, &#39;valences&#39;, &#39;hyb_types&#39;]:
                newkey = key if key[-1]!=&#39;s&#39; else key[:-1]
                atoms_dataframe[newkey] = atoms_dataframe.apply(lambda x:
                                                                                                                structure_dict[x[&#39;molecule_name&#39;]][key][x[&#39;atom_index&#39;]],
                                                                                                                axis=1)
                atoms_dataframe.rename(columns={&#39;long_symbol&#39;:&#39;labeled_atom&#39;},inplace=True)
        return atoms_dataframe</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code class="name flex">
<span>def <span class="ident">enhance_bonds</span></span>(<span>bond_dataframe, structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Enhance the bonds dataframe by including derived information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bond_dataframe</code></strong></dt>
<dd>Pandas dataframe read from train.csv or test.csv.</dd>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code>enhance_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pandas.DataFrame: Same dataframe, modified in-place, with derived information added.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enhance_bonds(bond_dataframe,structure_dict):
        &#34;&#34;&#34;Enhance the bonds dataframe by including derived information.

        Args:
                bond_dataframe: Pandas dataframe read from train.csv or test.csv.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: Same dataframe, modified in-place, with derived information added.

        &#34;&#34;&#34;
        bond_dataframe.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;],inplace=True)
        assert int(bond_dataframe.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_BOND_COUNT
        new_columns = collections.defaultdict(list)
        for index,row in bond_dataframe.iterrows():
                molecule_name, iatom0, iatom1 = row[&#39;molecule_name&#39;],row[&#39;atom_index_0&#39;],row[&#39;atom_index_1&#39;]
                if &#39;predict&#39; not in structure_dict[molecule_name]:
                        structure_dict[molecule_name][&#39;predict&#39;] = structure_dict[molecule_name][&#39;bond_orders&#39;] * 0
                structure_dict[molecule_name][&#39;predict&#39;][iatom0,iatom1] = 1
                structure_dict[molecule_name][&#39;predict&#39;][iatom1,iatom0] = 1
                long_symbols = [structure_dict[molecule_name][&#39;long_symbols&#39;][x] for x in [iatom0,iatom1]]

                # labeled_type
                if all([x[0]==&#39;H&#39; for x in long_symbols]):
                        lt = row[&#39;type&#39;]
                elif not any([x[0]==&#39;H&#39; for x in long_symbols]):
                        raise ValueError(&#34;No hydrogen found in {}&#34;.format(row))
                else:
                        ls = [x for x in long_symbols if x[0]!=&#39;H&#39;][0]
                        lt = row[&#34;type&#34;] + ls[1:].replace(&#39;.0&#39;,&#39;&#39;)
                        if lt in classification_corrections:
                                lt = classification_corrections[lt]
                        if lt in small_longtypes:
                                lt = lt.split(&#39;_&#39;)[0]
                new_columns[&#34;labeled_type&#34;].append(lt)

                # sublabeled type
                new_columns[&#34;sublabel_type&#34;].append(row[&#39;type&#39;] + &#39;-&#39;+ &#39;-&#39;.join(sorted(long_symbols)))
                # bond order
                new_columns[&#34;bond_order&#34;].append(structure_dict[molecule_name][&#39;bond_orders&#39;][iatom0,iatom1])
                new_columns[&#34;predict&#34;].append(1)
        for key in new_columns:
                bond_dataframe[key] = new_columns[key]
        return bond_dataframe</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code class="name flex">
<span>def <span class="ident">enhance_structure_dict</span></span>(<span>structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Add derived information to the structure dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>The same, modified in-place, with derived information (e.g. atom distances).</dd>
</dl>
<p>Caution: If torch is imported at the same time as this is run, you may get a segmentation fault. Complain to pybel or rdkit, I suppose.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enhance_structure_dict(structure_dict):
        &#34;&#34;&#34;Add derived information to the structure dictionary.

        Args:
                structure_dict: Output of :func:`make_structure_dict`.

        Returns:
                dict: The same, modified in-place, with derived information (e.g. atom distances).

        Caution: If torch is imported at the same time as this is run, you may get a segmentation fault. Complain to pybel or rdkit, I suppose.
        &#34;&#34;&#34;

        import pybel

        atomic_num_dict = { &#39;H&#39;:1, &#39;C&#39;:6, &#39;N&#39;:7, &#39;O&#39;:8, &#39;F&#39;:9 }


        for molecule_name in structure_dict:

                # positions - array (N,3) of Cartesian positions
                molecule = structure_dict[molecule_name]
                positions = np.array(molecule[&#39;positions&#39;])
                conn = np.array(molecule[&#39;conn&#39;])
                n_atom = positions.shape[0]
                molecule[&#39;positions&#39;] = positions

                # distances - array (N,N) of distances between atoms
                pos1 = np.tile(positions, (n_atom,1,1) )
                pos2 = np.transpose(pos1, (1,0,2) )
                dist = np.linalg.norm(pos1 - pos2, axis=-1)
                molecule[&#39;distances&#39;] = dist

                # angle - array (N,) of angles to the 2 closest atoms
                sorted_j = np.argsort(dist, axis=-1)
                relpos1 = positions[sorted_j[:,1],:] - positions[sorted_j[:,0],:]
                relpos2 = positions[sorted_j[:,2],:] - positions[sorted_j[:,0],:]
                cos = np.sum(relpos1*relpos2,axis=1) / (np.linalg.norm(relpos1,axis=1) * np.linalg.norm(relpos2,axis=1))
                angle = np.arccos( np.clip(cos,-1.0,1.0) ).reshape((n_atom,1)) / np.pi
                molecule[&#39;angle&#39;] = angle[:,0]

                # bond orders - array (N,N) of the bond order (0 for no chemical bond)
                # Note this relies on a few manual corrections
                molecule[&#39;bond_orders&#39;] = np.zeros((n_atom,n_atom))
                atomicNumList = [atomic_num_dict[symbol] for symbol in molecule[&#39;symbols&#39;]]

                for atom0 in range(len(molecule[&#39;symbols&#39;])):
                        for atom1 in range(len(molecule[&#39;symbols&#39;])):

                                molecule[&#39;bond_orders&#39;][atom0,atom1] = conn[atom0][atom1]
                                molecule[&#39;bond_orders&#39;][atom1,atom0] = conn[atom1][atom0]

                # Supplementary information for tagging:
                # top_bonds: (N,4 or less) bond orders of the top 4 bonds, for each atom
                # bond_ids: (N,4): Label the atom with the following 4 linear transform of top_bonds:
                #   * total num bonds (valence), counting double as 2
                #   * total num bonded neighbors, counting double as 1
                #   * largest order
                #   * second largest order.
                molecule[&#39;top_bonds&#39;] = np.sort(molecule[&#39;bond_orders&#39;],axis=-1)[:,-1:-5:-1]
                molecule[&#39;bond_ids&#39;] = np.hstack((molecule[&#39;top_bonds&#39;].sum(axis=-1)[:,np.newaxis],
                                                                                  np.sum(molecule[&#39;top_bonds&#39;]&gt;1e-3,axis=-1)[:,np.newaxis],
                                                                                  molecule[&#39;top_bonds&#39;][:,:2]))
                # long_symbols (N,) string relabel of the symbol straight from bond_ids
                molecule[&#39;long_symbols&#39;] = [&#39;_&#39;.join([
                        molecule[&#39;symbols&#39;][i]]+[str(x) for x in molecule[&#39;bond_ids&#39;][i]])
                                                                        for i in range(n_atom)]
                chem_bond_atoms = [sorted([molecule[&#39;symbols&#39;][i] for i in molecule[&#39;bond_orders&#39;][atom_index].nonzero()[0]])
                                                   for atom_index in range(n_atom)]
                molecule[&#39;sublabel_atom&#39;] = [&#39;-&#39;.join([molecule[&#39;long_symbols&#39;][atom_index]]+chem_bond_atoms[atom_index])
                                                                        for atom_index in range(n_atom)]

                # pybel information. I think we only end up using Gastiger charges.
                # Each of these is (N,) arrays
                # Convert to xyz string for pybel&#39;s I/O
                xyz = str(n_atom)+&#39;\n\n&#39; + &#39;\n&#39;.join([ &#39; &#39;.join( [
                                str(molecule[&#39;symbols&#39;][i]),
                                str(molecule[&#39;positions&#39;][i,0]),
                                str(molecule[&#39;positions&#39;][i,1]),
                                str(molecule[&#39;positions&#39;][i,2])] )
                                for i in range(n_atom)])

                mol = pybel.readstring(&#39;xyz&#39;,xyz)
                molecule[&#39;charges&#39;] = [mol.atoms[i].partialcharge for i in range(n_atom)]
                molecule[&#39;spins&#39;] = [mol.atoms[i].spin for i in range(n_atom)]
                molecule[&#39;heavyvalences&#39;] = [mol.atoms[i].heavyvalence for i in range(n_atom)]
                molecule[&#39;heterovalences&#39;] = [mol.atoms[i].heterovalence for i in range(n_atom)]
                molecule[&#39;valences&#39;] = [mol.atoms[i].valence for i in range(n_atom)]
                molecule[&#39;hyb_types&#39;] = [mol.atoms[i].type for i in range(n_atom)]

        return structure_dict</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling"><code class="name flex">
<span>def <span class="ident">get_scaling</span></span>(<span>bonds_train)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the mean/std scaling factors for each <code>labeled_type</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bonds_train</code></strong></dt>
<dd>The training data that we can use to set the values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tuple</code></strong></dt>
<dd>Mean and std dicts, mapping labeled_type to scalar_coupling_constant mean/std.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scaling(bonds_train):
        &#34;&#34;&#34;Get the mean/std scaling factors for each ``labeled_type``.

        Args:
                bonds_train: The training data that we can use to set the values.

        Returns:
                tuple: Mean and std dicts, mapping labeled_type to scalar_coupling_constant mean/std.

        &#34;&#34;&#34;
        # Get the mean/std scaling factors
        means = bonds_train.groupby(&#34;labeled_type&#34;).mean()[&#34;scalar_coupling_constant&#34;].to_dict()
        stds = bonds_train.groupby(&#34;labeled_type&#34;).std()[&#34;scalar_coupling_constant&#34;].to_dict()
        return means,stds</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets"><code class="name flex">
<span>def <span class="ident">make_quadruplets</span></span>(<span>molecule_list, structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Make the quadruplet dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>molecule_list</code></strong></dt>
<dd>List of molecules to generate.</dd>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code>enhance_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pandas.DataFrame: New dataframe, with quadruplets and related information. Make quadruplets. Convention is that they are connected 2-0-1-3, where 0,1 are the central atoms and 0-2 is a bond.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_quadruplets(molecule_list,structure_dict):
        &#34;&#34;&#34;Make the quadruplet dataframe.

        Args:
                molecule_list: List of molecules to generate.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with quadruplets and related information. Make quadruplets. Convention is that they are connected 2-0-1-3, where 0,1 are the central atoms and 0-2 is a bond.

        &#34;&#34;&#34;
        new_data = collections.defaultdict(list)
        icount = 0  # for debugging
        for molecule_name in molecule_list:
                molecule = structure_dict[molecule_name]
                bond_orders = molecule[&#39;bond_orders&#39;]
                short = molecule[&#39;symbols&#39;]
                long = molecule[&#39;long_symbols&#39;]
                pos = molecule[&#39;positions&#39;]
                for i,j in zip(*bond_orders.nonzero()):
                        if i &gt; j:
                                continue  # we will get it the other way
                        for i_nei,j_nei in itertools.product(
                                        bond_orders[i].nonzero()[0],bond_orders[j].nonzero()[0]):
                                if j_nei==i or i_nei==j:
                                        continue  # no self
                                # But we could have i_nei==j_nei, which is a triangle
                                # Atomic structure looks like i_nei-i-j-j_nei
                                # There&#39;s an easy way and a quick way.
                                mode = &#39;fast&#39;
                                assert [&#39;test&#39;,&#39;fast&#39;,&#39;slow&#39;].count(mode),&#39;Mode must be one of: test, fast, slow&#39;
                                if [&#39;test&#39;,&#39;slow&#39;].count(mode):
                                        plane_1 = np.cross( pos[i_nei]-pos[i], pos[j]-pos[i])
                                        plane_2 = np.cross( pos[i]-pos[j],pos[j_nei]-pos[j])
                                        if np.allclose(plane_1,0.) or np.allclose(plane_2,0.):
                                                # Planar; not really a dihedral
                                                continue
                                        # Compute the dihedral in radians
                                        costheta = np.dot(plane_1,plane_2) / (
                                                np.linalg.norm(plane_1)*np.linalg.norm(plane_2))
                                        costheta1 = costheta
                                if [&#39;test&#39;,&#39;fast&#39;].count(mode):  # this way is much faster
                                        # Uses some clever algebra
                                        ijpos = np.array([
                                                        pos[i_nei] - pos[i],
                                                        pos[j] - pos[i],
                                                        pos[j_nei] - pos[j],
                                                        ])
                                        # For simplicity, call these a,b,c
                                        dots = np.dot(ijpos,ijpos.T)
                                        # numerator = (a x b).(-b x c)
                                        # denominator = |a x b| |b x c|
                                        # So:
                                        # -(axb).(bxc) = (b.b)(a.c) - (a.b)(b.c)
                                        numerator = dots[1,1]*dots[0,2] - dots[0,1]*dots[1,2]
                                        # |axb|^2=|a|^2|b|^2-(a.b)^2
                                        denominator = np.sqrt( (
                                                        dots[0,0]*dots[1,1]-dots[0,1]**2) * (
                                                        dots[2,2]*dots[1,1]-dots[2,1]**2 ))
                                        if abs(denominator) &lt; 1e-7:
                                                # Planar, not really a dihedral
                                                continue
                                        costheta = numerator / denominator
                                if mode==&#39;test&#39;:
                                        assert abs(costheta-costheta1)&lt;1e-4,&#34;Fancy algebra failed&#34;
                                        icount += 1
                                        if icount &gt; 50000:
                                                raise Exception(&#34;50K counts confirmed.&#34;)
                                assert abs(costheta)&lt;1.0001,&#39;Cos theta too large&#39;
                                dihedral = np.arccos( np.clip(costheta,-1.0,1.0) )
                                # Start labeling
                                label = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei]]),
                                        &#39;_&#39;.join([short[j],short[j_nei]]),
                                        ]))

                                # This definition finds several unique labels in the test set, e.g. &#39;C3_C4_C4_N4&#39;
                                #sublabel = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]+long[i_nei].split(&#39;_&#39;)[1]]),
                                #    &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]+long[j_nei].split(&#39;_&#39;)[1]]),
                                #    ])).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, e.g. C_3_3_1_1_C_C_4_4_1_1_N
                                #sublabel2 = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([long[i],short[i_nei]]),
                                #    &#39;_&#39;.join([long[j],short[j_nei]]),
                                #    ])).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, {&#39;C_O_1_N_C_2_2&#39;,
                                # &#39;N_C_1_N_O_1_2&#39;, &#39;N_N_2_O_C_1_1&#39;}
                                sublabel4 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei],str(bond_orders[i,i_nei].round(1))]),
                                        &#39;_&#39;.join([short[j],short[j_nei],str(bond_orders[j,j_nei].round(1))]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                # This definition finds several unique labels in the test set, e.g. C3_C4_1_C4_N4_1_1&#39;
                                #sublabel4 = &#39;_&#39;.join(sorted([
                                #    &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]+long[i_nei].split(&#39;_&#39;)[1],
                                #        str(bond_orders[i,i_nei].round(1))]),
                                #    &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]+long[j_nei].split(&#39;_&#39;)[1],
                                #        str(bond_orders[j,j_nei].round(1))]),
                                #    ]) + [str(bond_orders[i,j].round(1))]
                                #    ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i],short[i_nei]]),
                                        &#39;_&#39;.join([short[j],short[j_nei]]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel2 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]]),
                                        &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]]),
                                        ]) + [str(bond_orders[i,j].round(1))]
                                        ).replace(&#39;.0&#39;,&#39;&#39;)

                                sublabel3 = &#39;_&#39;.join(sorted([
                                        &#39;_&#39;.join([short[i]+long[i].split(&#39;_&#39;)[1],short[i_nei]]),
                                        &#39;_&#39;.join([short[j]+long[j].split(&#39;_&#39;)[1],short[j_nei]]),
                                        ])).replace(&#39;.0&#39;,&#39;&#39;)
                                row = {&#39;molecule_name&#39;:molecule_name,
                                           &#39;atom_index_0&#39;:i,&#39;atom_index_1&#39;:j,&#39;atom_index_2&#39;:i_nei,&#39;atom_index_3&#39;:j_nei,
                                          &#39;label&#39;:label,&#39;sublabel&#39;:sublabel,&#39;sublabel2&#39;:sublabel2,&#39;sublabel3&#39;:sublabel3,
                                           &#39;sublabel4&#39;:sublabel4,&#39;angle&#39;:dihedral}
                                for k,v in row.items():
                                        new_data[k].append(v)
        ans = pd.DataFrame(new_data)
        ans.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;,&#39;atom_index_3&#39;])
        assert int(ans.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_QUAD_COUNT
        return ans</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code class="name flex">
<span>def <span class="ident">make_structure_dict</span></span>(<span>atoms_dataframe)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert from structures.csv output to a dictionary data storage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>atoms_dataframe</code></strong></dt>
<dd>The dataframe corresponding to structures.csv</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dict</code></strong></dt>
<dd>Mapping of molecule name to molecule properties.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_structure_dict(atoms_dataframe):
        &#34;&#34;&#34;Convert from structures.csv output to a dictionary data storage.

        Args:
                atoms_dataframe: The dataframe corresponding to structures.csv

        Returns:
                dict: Mapping of molecule name to molecule properties.

        &#34;&#34;&#34;
        atoms = atoms_dataframe.sort_values([&#34;molecule_name&#34;, &#34;atom_index&#34;])  # ensure ordering is consistent
        # Make a molecule-based dictionary of the information
        structure_dict = collections.defaultdict(lambda: {&#34;symbols&#34;:[],&#34;positions&#34;:[],&#34;conn&#34;:[]})
        for index,row in atoms.iterrows():
                structure_dict[row[&#34;molecule_name&#34;]][&#34;symbols&#34;].append(row[&#34;atom&#34;])
                structure_dict[row[&#34;molecule_name&#34;]][&#34;positions&#34;].append([row[&#34;x&#34;],row[&#34;y&#34;],row[&#34;z&#34;]])
                structure_dict[row[&#34;molecule_name&#34;]][&#34;conn&#34;].append(row[&#34;conn&#34;])

        return structure_dict</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets"><code class="name flex">
<span>def <span class="ident">make_triplets</span></span>(<span>molecule_list, structure_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Make the triplet dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>molecule_list</code></strong></dt>
<dd>List of molecules to generate.</dd>
<dt><strong><code>structure_dict</code></strong></dt>
<dd>Output of :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict"><code>make_structure_dict()</code></a>, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict"><code>enhance_structure_dict()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>pandas.DataFrame: New dataframe, with triplets and related information. The convention is the bond looks like 1-0-2, where 0 is the central atom.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_triplets(molecule_list,structure_dict):
        &#34;&#34;&#34;Make the triplet dataframe.

        Args:
                molecule_list: List of molecules to generate.
                structure_dict: Output of :func:`make_structure_dict`, after running :func:`enhance_structure_dict`.

        Returns:
                pandas.DataFrame: New dataframe, with triplets and related information. The convention is the bond looks like 1-0-2, where 0 is the central atom.

        &#34;&#34;&#34;
        new_data = collections.defaultdict(list)
        for molecule_name in molecule_list:
                molecule = structure_dict[molecule_name]
                bond_orders = molecule[&#39;bond_orders&#39;]
                short = molecule[&#39;symbols&#39;]
                long = molecule[&#39;long_symbols&#39;]
                for i, atom_bond_order in enumerate(bond_orders):
                        connection_indices = atom_bond_order.nonzero()[0]
                        pairs = itertools.combinations(connection_indices,2)
                        for pair in pairs:
                                j, k = pair[0], pair[1]
                                atom0_short = short[i] + long[i].split(&#39;_&#39;)[2]
                                atom1_short = short[j] + long[j].split(&#39;_&#39;)[2]
                                atom2_short = short[k] + long[k].split(&#39;_&#39;)[2]
                                atom0_long = long[i]
                                atom1_long = long[j]
                                atom2_long = long[k]
                                #labels = [&#39;-&#39;.join([atom1_short,str(atom_bond_order[j])]),
                                #          &#39;-&#39;.join([atom2_short,str(atom_bond_order[k])])]
                                labels = [atom1_short,atom2_short]
                                labels.sort()
                                label = &#39;-&#39;.join([atom0_short]+labels)
                                #sublabels = [&#39;-&#39;.join([atom1_long,str(atom_bond_order[j])]),
                                #             &#39;-&#39;.join([atom2_long,str(atom_bond_order[k])])]
                                sublabels = [atom1_long,atom2_long]
                                sublabels.sort()
                                sublabel = &#39;-&#39;.join([atom0_long]+sublabels)
                                r10 = molecule[&#39;positions&#39;][j] - molecule[&#39;positions&#39;][i]
                                r20 = molecule[&#39;positions&#39;][k] - molecule[&#39;positions&#39;][i]
                                angle = np.sum(r10*r20) / (np.linalg.norm(r10)*np.linalg.norm(r20))
                                angle = np.arccos( np.clip(angle,-1.0,1.0) )
                                row = {&#39;molecule_name&#39;:molecule_name,&#39;atom_index_0&#39;:i,&#39;atom_index_1&#39;:j,&#39;atom_index_2&#39;:k,
                                          &#39;label&#39;:label,&#39;sublabel&#39;:sublabel,&#39;angle&#39;:angle}
                                for k,v in row.items():
                                        new_data[k].append(v)
        ans = pd.DataFrame(new_data)
        ans.sort_values([&#39;molecule_name&#39;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;])
        assert int(ans.groupby(&#34;molecule_name&#34;).count().max()[0]) &lt;= MAX_TRIPLET_COUNT
        return ans</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.write_csv"><code class="name flex">
<span>def <span class="ident">write_csv</span></span>(<span>directory, label, atoms, bonds, triplets, quadruplets)</span>
</code></dt>
<dd>
<section class="desc"><p>Write the relevant dataframes to a CSV file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong></dt>
<dd>Directory to write to.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>How to label the files, e.g. test or train.</dd>
<dt><strong><code>atoms</code></strong></dt>
<dd>Pandas dataframe read from structures.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms"><code>enhance_atoms()</code></a>.</dd>
<dt><strong><code>bonds</code></strong></dt>
<dd>Pandas dataframe read from train.csv or test.csv, after running :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds"><code>enhance_bonds()</code></a>.</dd>
<dt><strong><code>triplets</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets"><code>make_triplets()</code></a>.</dd>
<dt><strong><code>quadruplets</code></strong></dt>
<dd>Pandas dataframe created by :func:<a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets"><code>make_quadruplets()</code></a>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_csv(directory,label,atoms,bonds,triplets,quadruplets):
        &#34;&#34;&#34;Write the relevant dataframes to a CSV file.

        Args:
                directory: Directory to write to.
                label (str): How to label the files, e.g. test or train.
                atoms: Pandas dataframe read from structures.csv, after running :func:`enhance_atoms`.
                bonds: Pandas dataframe read from train.csv or test.csv, after running :func:`enhance_bonds`.
                triplets: Pandas dataframe created by :func:`make_triplets`.
                quadruplets: Pandas dataframe created by :func:`make_quadruplets`.

        Returns:
                None

        &#34;&#34;&#34;
        filename = os.path.join(directory,&#39;new_big_{}.csv.bz2&#39;)
        if atoms is not None and len(atoms):
                atoms = atoms.sort_values([&#34;molecule_name&#34;,&#39;atom_index&#39;])
                for i in range(4):
                        atoms[&#34;top_bond_{}&#34;.format(i)] = [x[i] if len(x)&gt;i else 0.0 for x in atoms[&#34;top_bond&#34;].values]
                for i in [&#34;x&#34;,&#34;y&#34;,&#34;z&#34;]:
                        atoms[i] = atoms[i].values.round(10)
                renames = {k:k[:-1] for k in atoms.columns if k[-1]==&#39;s&#39;}
                renames.update({&#39;long_symbols&#39;:&#39;labeled_atom&#39;})
                atoms = atoms.rename(columns=renames)
                atoms.to_csv(filename.format(&#39;structures&#39;),index=False,columns=
                        &#39;molecule_name,atom_index,atom,x,y,z,labeled_atom,angle,top_bond_0,top_bond_1,top_bond_2,top_bond_3,sublabel_atom,charge,spin,heavyvalence,heterovalence,valence,hyb_type&#39;.split(&#39;,&#39;))
        if bonds is not None and len(bonds):
                bonds = bonds.reset_index()
                bond_columns = &#39;id,molecule_name,atom_index_0,atom_index_1,type,scalar_coupling_constant,labeled_type,sublabel_type,bond_order,predict&#39;.split(&#39;,&#39;)
                if &#39;scalar_coupling_constant&#39; not in bonds.columns:
                        bond_columns = [x for x in bond_columns if x!=&#39;scalar_coupling_constant&#39;]
                bonds = bonds.sort_values([&#34;predict&#34;,&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;],
                                                                  ascending=[False,True,True,True])
                bonds.to_csv(filename.format(label),index=False,columns=bond_columns)
        if triplets is not None and len(triplets):
                triplets = triplets.sort_values([&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,&#39;atom_index_2&#39;])
                triplets.to_csv(filename.format(label+&#39;_triplets&#39;),index=False,columns=
                        &#39;molecule_name,atom_index_0,atom_index_1,atom_index_2,label,sublabel,angle&#39;.split(&#39;,&#39;))
        if quadruplets is not None and len(quadruplets):
                quadruplets = quadruplets.sort_values([&#34;molecule_name&#34;,&#39;atom_index_0&#39;,&#39;atom_index_1&#39;,
                                                                                           &#39;atom_index_2&#39;,&#39;atom_index_3&#39;])
                quadruplets.to_csv(filename.format(label+&#39;_quadruplets&#39;),index=False,columns=
                        &#39;molecule_name,atom_index_0,atom_index_1,atom_index_2,atom_index_3,label,sublabel,sublabel2,sublabel3,sublabel4,angle&#39;.split(&#39;,&#39;))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="autoENRICH.ml.features.BCAI_calc" href="index.html">autoENRICH.ml.features.BCAI_calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_all_pairs" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_all_pairs">add_all_pairs</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_embedding" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_embedding">add_embedding</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_scaling" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.add_scaling">add_scaling</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.create_dataset" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.create_dataset">create_dataset</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_atoms">enhance_atoms</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_bonds">enhance_bonds</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.enhance_structure_dict">enhance_structure_dict</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.get_scaling">get_scaling</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_quadruplets">make_quadruplets</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_structure_dict">make_structure_dict</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.make_triplets">make_triplets</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.mol_graph_setup.write_csv" href="#autoENRICH.ml.features.BCAI_calc.mol_graph_setup.write_csv">write_csv</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>