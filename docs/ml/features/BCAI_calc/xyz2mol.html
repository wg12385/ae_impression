<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>autoENRICH.ml.features.BCAI_calc.xyz2mol API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>autoENRICH.ml.features.BCAI_calc.xyz2mol</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">## This source code is from xyz2mol written by Jensen Group
##   (https://github.com/jensengroup/xyz2mol/tree/master)
##
##
##MIT License
##
##Copyright (c) 2018 Jensen Group
##
##Permission is hereby granted, free of charge, to any person obtaining a copy
##of this software and associated documentation files (the &#34;Software&#34;), to deal
##in the Software without restriction, including without limitation the rights
##to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
##copies of the Software, and to permit persons to whom the Software is
##furnished to do so, subject to the following conditions:
##
##The above copyright notice and this permission notice shall be included in all
##copies or substantial portions of the Software.
##
##THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
##IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
##FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
##AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
##LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
##OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
##SOFTWARE.

from rdkit import Chem
from rdkit.Chem import AllChem
import itertools
from rdkit.Chem import rdmolops
from collections import defaultdict
import copy
#import networkx as nx #uncomment if you don&#39;t want to use &#34;quick&#34;/install networkx


global __ATOM_LIST__
__ATOM_LIST__ = [ x.strip() for x in [&#39;h &#39;,&#39;he&#39;, \
      &#39;li&#39;,&#39;be&#39;,&#39;b &#39;,&#39;c &#39;,&#39;n &#39;,&#39;o &#39;,&#39;f &#39;,&#39;ne&#39;, \
      &#39;na&#39;,&#39;mg&#39;,&#39;al&#39;,&#39;si&#39;,&#39;p &#39;,&#39;s &#39;,&#39;cl&#39;,&#39;ar&#39;, \
      &#39;k &#39;,&#39;ca&#39;,&#39;sc&#39;,&#39;ti&#39;,&#39;v &#39;,&#39;cr&#39;,&#39;mn&#39;,&#39;fe&#39;,&#39;co&#39;,&#39;ni&#39;,&#39;cu&#39;, \
      &#39;zn&#39;,&#39;ga&#39;,&#39;ge&#39;,&#39;as&#39;,&#39;se&#39;,&#39;br&#39;,&#39;kr&#39;, \
      &#39;rb&#39;,&#39;sr&#39;,&#39;y &#39;,&#39;zr&#39;,&#39;nb&#39;,&#39;mo&#39;,&#39;tc&#39;,&#39;ru&#39;,&#39;rh&#39;,&#39;pd&#39;,&#39;ag&#39;, \
      &#39;cd&#39;,&#39;in&#39;,&#39;sn&#39;,&#39;sb&#39;,&#39;te&#39;,&#39;i &#39;,&#39;xe&#39;, \
      &#39;cs&#39;,&#39;ba&#39;,&#39;la&#39;,&#39;ce&#39;,&#39;pr&#39;,&#39;nd&#39;,&#39;pm&#39;,&#39;sm&#39;,&#39;eu&#39;,&#39;gd&#39;,&#39;tb&#39;,&#39;dy&#39;, \
      &#39;ho&#39;,&#39;er&#39;,&#39;tm&#39;,&#39;yb&#39;,&#39;lu&#39;,&#39;hf&#39;,&#39;ta&#39;,&#39;w &#39;,&#39;re&#39;,&#39;os&#39;,&#39;ir&#39;,&#39;pt&#39;, \
      &#39;au&#39;,&#39;hg&#39;,&#39;tl&#39;,&#39;pb&#39;,&#39;bi&#39;,&#39;po&#39;,&#39;at&#39;,&#39;rn&#39;, \
      &#39;fr&#39;,&#39;ra&#39;,&#39;ac&#39;,&#39;th&#39;,&#39;pa&#39;,&#39;u &#39;,&#39;np&#39;,&#39;pu&#39;] ]


def get_atom(atom):
    global __ATOM_LIST__
    atom = atom.lower()
    return __ATOM_LIST__.index(atom) + 1


def getUA(maxValence_list, valence_list):
    UA = []
    DU = []
    for i, (maxValence,valence) in enumerate(zip(maxValence_list, valence_list)):
        if maxValence - valence &gt; 0:
            UA.append(i)
            DU.append(maxValence - valence)
    return UA,DU


def get_BO(AC,UA,DU,valences,UA_pairs,quick):
    BO = AC.copy()
    DU_save = []

    while DU_save != DU:
        for i,j in UA_pairs:
            BO[i,j] += 1
            BO[j,i] += 1

        BO_valence = list(BO.sum(axis=1))
        DU_save = copy.copy(DU)
        UA, DU = getUA(valences, BO_valence)
        UA_pairs = get_UA_pairs(UA,AC,quick)[0]

    return BO


def valences_not_too_large(BO,valences):
    number_of_bonds_list = BO.sum(axis=1)
    for valence, number_of_bonds in zip(valences,number_of_bonds_list):
        if number_of_bonds &gt; valence:
            return False

    return True


def BO_is_OK(BO,AC,charge,DU,atomic_valence_electrons,atomicNumList,charged_fragments):
    Q = 0 # total charge
    q_list = []
    if charged_fragments:
        BO_valences = list(BO.sum(axis=1))
        for i,atom in enumerate(atomicNumList):
            q = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])
            Q += q
            if atom == 6:
                number_of_single_bonds_to_C = list(BO[i,:]).count(1)
                if number_of_single_bonds_to_C == 2 and BO_valences[i] == 2:
                    Q += 1
                    q = 2
                if number_of_single_bonds_to_C == 3 and Q + 1 &lt; charge:
                    Q += 2
                    q = 1

            if q != 0:
                q_list.append(q)

    if (BO-AC).sum() == sum(DU) and charge == Q and len(q_list) &lt;= abs(charge):
        return True
    else:
        return False


def get_atomic_charge(atom,atomic_valence_electrons,BO_valence):
    if atom == 1:
        charge = 1 - BO_valence
    elif atom == 5:
        charge = 3 - BO_valence
    elif atom == 15 and BO_valence == 5:
        charge = 0
    elif atom == 16 and BO_valence == 6:
        charge = 0
    else:
        charge = atomic_valence_electrons - 8 + BO_valence

    return charge

def clean_charges(mol):
# this hack should not be needed any more but is kept just in case
#

    rxn_smarts = [&#39;[N+:1]=[*:2]-[C-:3]&gt;&gt;[N+0:1]-[*:2]=[C-0:3]&#39;,
                  &#39;[N+:1]=[*:2]-[O-:3]&gt;&gt;[N+0:1]-[*:2]=[O-0:3]&#39;,
                  &#39;[N+:1]=[*:2]-[*:3]=[*:4]-[O-:5]&gt;&gt;[N+0:1]-[*:2]=[*:3]-[*:4]=[O-0:5]&#39;,
                  &#39;[#8:1]=[#6:2]([!-:6])[*:3]=[*:4][#6-:5]&gt;&gt;[*-:1][*:2]([*:6])=[*:3][*:4]=[*+0:5]&#39;,
                  &#39;[O:1]=[c:2][c-:3]&gt;&gt;[*-:1][*:2][*+0:3]&#39;,
                  &#39;[O:1]=[C:2][C-:3]&gt;&gt;[*-:1][*:2]=[*+0:3]&#39;]

    fragments = Chem.GetMolFrags(mol,asMols=True,sanitizeFrags=False)

    for i,fragment in enumerate(fragments):
        for smarts in rxn_smarts:
            patt = Chem.MolFromSmarts(smarts.split(&#34;&gt;&gt;&#34;)[0])
            while fragment.HasSubstructMatch(patt):
                rxn = AllChem.ReactionFromSmarts(smarts)
                ps = rxn.RunReactants((fragment,))
                fragment = ps[0][0]
        if i == 0:
            mol = fragment
        else:
            mol = Chem.CombineMols(mol,fragment)

    return mol


def BO2mol(mol,BO_matrix, atomicNumList,atomic_valence_electrons,mol_charge,charged_fragments):
# based on code written by Paolo Toscani

    l = len(BO_matrix)
    l2 = len(atomicNumList)
    BO_valences = list(BO_matrix.sum(axis=1))

    if (l != l2):
        raise RuntimeError(&#39;sizes of adjMat ({0:d}) and atomicNumList &#39;
            &#39;{1:d} differ&#39;.format(l, l2))

    rwMol = Chem.RWMol(mol)

    bondTypeDict = {
        1: Chem.BondType.SINGLE,
        2: Chem.BondType.DOUBLE,
        3: Chem.BondType.TRIPLE
    }

    for i in range(l):
        for j in range(i + 1, l):
            bo = int(round(BO_matrix[i, j]))
            if (bo == 0):
                continue
            bt = bondTypeDict.get(bo, Chem.BondType.SINGLE)
            rwMol.AddBond(i, j, bt)
    mol = rwMol.GetMol()

    if charged_fragments:
        mol = set_atomic_charges(mol,atomicNumList,atomic_valence_electrons,BO_valences,BO_matrix,mol_charge)
    else:
        mol = set_atomic_radicals(mol,atomicNumList,atomic_valence_electrons,BO_valences)

    return mol

def set_atomic_charges(mol,atomicNumList,atomic_valence_electrons,BO_valences,BO_matrix,mol_charge):
    q = 0
    for i,atom in enumerate(atomicNumList):
        a = mol.GetAtomWithIdx(i)
        charge = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])
        q += charge
        if atom == 6:
            number_of_single_bonds_to_C = list(BO_matrix[i,:]).count(1)
            if number_of_single_bonds_to_C == 2 and BO_valences[i] == 2:
                    q += 1
                    charge = 0
            if number_of_single_bonds_to_C == 3 and q + 1 &lt; mol_charge:
                    q += 2
                    charge = 1

        if (abs(charge) &gt; 0):
            a.SetFormalCharge(int(charge))

    # shouldn&#39;t be needed anymore bit is kept just in case
    #mol = clean_charges(mol)

    return mol


def set_atomic_radicals(mol,atomicNumList,atomic_valence_electrons,BO_valences):
# The number of radical electrons = absolute atomic charge
    for i,atom in enumerate(atomicNumList):
        a = mol.GetAtomWithIdx(i)
        charge = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])

        if (abs(charge) &gt; 0):
            a.SetNumRadicalElectrons(abs(int(charge)))

    return mol

def get_bonds(UA,AC):
    bonds = []

    for k,i in enumerate(UA):
        for j in UA[k+1:]:
            if AC[i,j] == 1:
                bonds.append(tuple(sorted([i,j])))

    return bonds

def get_UA_pairs(UA,AC,quick):
    bonds = get_bonds(UA,AC)
    if len(bonds) == 0:
        return [()]

    if quick:
        G=nx.Graph()
        G.add_edges_from(bonds)
        UA_pairs = [list(nx.max_weight_matching(G))]
        return UA_pairs

    max_atoms_in_combo = 0
    UA_pairs = [()]
    for combo in list(itertools.combinations(bonds, int(len(UA)/2))):
        flat_list = [item for sublist in combo for item in sublist]
        atoms_in_combo = len(set(flat_list))
        if atoms_in_combo &gt; max_atoms_in_combo:
            max_atoms_in_combo = atoms_in_combo
            UA_pairs = [combo]
 #           if quick and max_atoms_in_combo == 2*int(len(UA)/2):
 #               return UA_pairs
        elif atoms_in_combo == max_atoms_in_combo:
            UA_pairs.append(combo)

    return UA_pairs

def AC2BO(AC,atomicNumList,charge,charged_fragments,quick):
    # TODO
    atomic_valence = defaultdict(list)
    atomic_valence[1] = [1]
    atomic_valence[6] = [4]
    atomic_valence[7] = [4,3]
    atomic_valence[8] = [2,1]
    atomic_valence[9] = [1]
    atomic_valence[14] = [4]
    atomic_valence[15] = [5,4,3]
    atomic_valence[16] = [6,4,2]
    atomic_valence[17] = [1]
    atomic_valence[32] = [4]
    atomic_valence[35] = [1]
    atomic_valence[53] = [1]


    atomic_valence_electrons = {}
    atomic_valence_electrons[1] = 1
    atomic_valence_electrons[6] = 4
    atomic_valence_electrons[7] = 5
    atomic_valence_electrons[8] = 6
    atomic_valence_electrons[9] = 7
    atomic_valence_electrons[14] = 4
    atomic_valence_electrons[15] = 5
    atomic_valence_electrons[16] = 6
    atomic_valence_electrons[17] = 7
    atomic_valence_electrons[32] = 4
    atomic_valence_electrons[35] = 7
    atomic_valence_electrons[53] = 7

# make a list of valences, e.g. for CO: [[4],[2,1]]
    valences_list_of_lists = []
    for atomicNum in atomicNumList:
        valences_list_of_lists.append(atomic_valence[atomicNum])

# convert [[4],[2,1]] to [[4,2],[4,1]]
    valences_list = itertools.product(*valences_list_of_lists)

    best_BO = AC.copy()

# implemenation of algorithm shown in Figure 2
# UA: unsaturated atoms
# DU: degree of unsaturation (u matrix in Figure)
# best_BO: Bcurr in Figure
#

    for valences in valences_list:
        AC_valence = list(AC.sum(axis=1))
        UA,DU_from_AC = getUA(valences, AC_valence)

        if len(UA) == 0 and BO_is_OK(AC,AC,charge,DU_from_AC,atomic_valence_electrons,atomicNumList,charged_fragments):
            return AC,atomic_valence_electrons

        UA_pairs_list = get_UA_pairs(UA,AC,quick)
        for UA_pairs in UA_pairs_list:
            BO = get_BO(AC,UA,DU_from_AC,valences,UA_pairs,quick)
            if BO_is_OK(BO,AC,charge,DU_from_AC,atomic_valence_electrons,atomicNumList,charged_fragments):
                return BO,atomic_valence_electrons

            elif BO.sum() &gt;= best_BO.sum() and valences_not_too_large(BO,valences):
                best_BO = BO.copy()

    return best_BO,atomic_valence_electrons


def AC2mol(mol,AC,atomicNumList,charge,charged_fragments,quick):
# convert AC matrix to bond order (BO) matrix
    BO,atomic_valence_electrons = AC2BO(AC,atomicNumList,charge,charged_fragments,quick)

# add BO connectivity and charge info to mol object
    mol = BO2mol(mol,BO, atomicNumList,atomic_valence_electrons,charge,charged_fragments)

    return mol


def get_proto_mol(atomicNumList):
    mol = Chem.MolFromSmarts(&#34;[#&#34;+str(atomicNumList[0])+&#34;]&#34;)
    rwMol = Chem.RWMol(mol)
    for i in range(1,len(atomicNumList)):
        a = Chem.Atom(atomicNumList[i])
        rwMol.AddAtom(a)

    mol = rwMol.GetMol()

    return mol


def get_atomicNumList(atomic_symbols):
    atomicNumList = []
    for symbol in atomic_symbols:
        atomicNumList.append(get_atom(symbol))
    return atomicNumList


def read_xyz_file(filename):

    atomic_symbols = []
    xyz_coordinates = []

    with open(filename, &#34;r&#34;) as file:
        for line_number,line in enumerate(file):
            if line_number == 0:
                num_atoms = int(line)
            elif line_number == 1:
                if &#34;charge=&#34; in line:
                    charge = int(line.split(&#34;=&#34;)[1])
                else:
                    charge = 0
            else:
                atomic_symbol, x, y, z = line.split()
                atomic_symbols.append(atomic_symbol)
                xyz_coordinates.append([float(x),float(y),float(z)])

    atomicNumList = get_atomicNumList(atomic_symbols)

    return atomicNumList,charge,xyz_coordinates

def xyz2AC(atomicNumList,xyz):
    import numpy as np
    mol = get_proto_mol(atomicNumList)

    conf = Chem.Conformer(mol.GetNumAtoms())
    for i in range(mol.GetNumAtoms()):
        conf.SetAtomPosition(i,(xyz[i][0],xyz[i][1],xyz[i][2]))
    mol.AddConformer(conf)

    dMat = Chem.Get3DDistanceMatrix(mol)
    pt = Chem.GetPeriodicTable()

    num_atoms = len(atomicNumList)
    AC = np.zeros((num_atoms,num_atoms)).astype(int)

    for i in range(num_atoms):
        a_i = mol.GetAtomWithIdx(i)
        Rcov_i = pt.GetRcovalent(a_i.GetAtomicNum())*1.30
        for j in range(i+1,num_atoms):
            a_j = mol.GetAtomWithIdx(j)
            Rcov_j = pt.GetRcovalent(a_j.GetAtomicNum())*1.30
            if dMat[i,j] &lt;= Rcov_i + Rcov_j:
                AC[i,j] = 1
                AC[j,i] = 1

    return AC,mol

def chiral_stereo_check(mol):
    Chem.SanitizeMol(mol)
    Chem.DetectBondStereochemistry(mol,-1)
    Chem.AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
    Chem.AssignAtomChiralTagsFromStructure(mol,-1)

    return mol

def xyz2mol(atomicNumList,charge,xyz_coordinates,charged_fragments,quick):

# Get atom connectivity (AC) matrix, list of atomic numbers, molecular charge,
# and mol object with no connectivity information
    AC,mol = xyz2AC(atomicNumList,xyz_coordinates)

# Convert AC to bond order matrix and add connectivity and charge info to mol object
    new_mol = AC2mol(mol,AC,atomicNumList,charge,charged_fragments,quick)

# Check for stereocenters and chiral centers
    new_mol = chiral_stereo_check(new_mol)

    return new_mol

if __name__ == &#34;__main__&#34;:

    import argparse

    parser = argparse.ArgumentParser(usage=&#39;%(prog)s [options] molecule.xyz&#39;)
    parser.add_argument(&#39;structure&#39;, metavar=&#39;structure&#39;, type=str)
    parser.add_argument(&#39;-s&#39;, &#39;--sdf&#39;, action=&#34;store_true&#34;, help=&#34;Dump sdf file&#34;)
    args = parser.parse_args()


    filename = args.structure
    charged_fragments = True # alternatively radicals are made

    # quick is faster for large systems but requires networkx
    # if you don&#39;t want to install networkx set quick=False and
    # uncomment &#39;import networkx as nx&#39; at the top of the file
    quick = True

    atomicNumList, charge, xyz_coordinates = read_xyz_file(filename)

    mol = xyz2mol(atomicNumList, charge, xyz_coordinates, charged_fragments, quick)

    if args.sdf:
        filename = filename.replace(&#34;.xyz&#34;, &#34;&#34;)
        filename += &#34;.sdf&#34;
        writer = Chem.SDWriter(filename)
        writer.write(mol)

    # Canonical hack
    smiles = Chem.MolToSmiles(mol, isomericSmiles=True)
    m = Chem.MolFromSmiles(smiles)
    smiles = Chem.MolToSmiles(m, isomericSmiles=True)

    print(smiles)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2BO"><code class="name flex">
<span>def <span class="ident">AC2BO</span></span>(<span>AC, atomicNumList, charge, charged_fragments, quick)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AC2BO(AC,atomicNumList,charge,charged_fragments,quick):
    # TODO
    atomic_valence = defaultdict(list)
    atomic_valence[1] = [1]
    atomic_valence[6] = [4]
    atomic_valence[7] = [4,3]
    atomic_valence[8] = [2,1]
    atomic_valence[9] = [1]
    atomic_valence[14] = [4]
    atomic_valence[15] = [5,4,3]
    atomic_valence[16] = [6,4,2]
    atomic_valence[17] = [1]
    atomic_valence[32] = [4]
    atomic_valence[35] = [1]
    atomic_valence[53] = [1]


    atomic_valence_electrons = {}
    atomic_valence_electrons[1] = 1
    atomic_valence_electrons[6] = 4
    atomic_valence_electrons[7] = 5
    atomic_valence_electrons[8] = 6
    atomic_valence_electrons[9] = 7
    atomic_valence_electrons[14] = 4
    atomic_valence_electrons[15] = 5
    atomic_valence_electrons[16] = 6
    atomic_valence_electrons[17] = 7
    atomic_valence_electrons[32] = 4
    atomic_valence_electrons[35] = 7
    atomic_valence_electrons[53] = 7

# make a list of valences, e.g. for CO: [[4],[2,1]]
    valences_list_of_lists = []
    for atomicNum in atomicNumList:
        valences_list_of_lists.append(atomic_valence[atomicNum])

# convert [[4],[2,1]] to [[4,2],[4,1]]
    valences_list = itertools.product(*valences_list_of_lists)

    best_BO = AC.copy()

# implemenation of algorithm shown in Figure 2
# UA: unsaturated atoms
# DU: degree of unsaturation (u matrix in Figure)
# best_BO: Bcurr in Figure
#

    for valences in valences_list:
        AC_valence = list(AC.sum(axis=1))
        UA,DU_from_AC = getUA(valences, AC_valence)

        if len(UA) == 0 and BO_is_OK(AC,AC,charge,DU_from_AC,atomic_valence_electrons,atomicNumList,charged_fragments):
            return AC,atomic_valence_electrons

        UA_pairs_list = get_UA_pairs(UA,AC,quick)
        for UA_pairs in UA_pairs_list:
            BO = get_BO(AC,UA,DU_from_AC,valences,UA_pairs,quick)
            if BO_is_OK(BO,AC,charge,DU_from_AC,atomic_valence_electrons,atomicNumList,charged_fragments):
                return BO,atomic_valence_electrons

            elif BO.sum() &gt;= best_BO.sum() and valences_not_too_large(BO,valences):
                best_BO = BO.copy()

    return best_BO,atomic_valence_electrons</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2mol"><code class="name flex">
<span>def <span class="ident">AC2mol</span></span>(<span>mol, AC, atomicNumList, charge, charged_fragments, quick)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AC2mol(mol,AC,atomicNumList,charge,charged_fragments,quick):
# convert AC matrix to bond order (BO) matrix
    BO,atomic_valence_electrons = AC2BO(AC,atomicNumList,charge,charged_fragments,quick)

# add BO connectivity and charge info to mol object
    mol = BO2mol(mol,BO, atomicNumList,atomic_valence_electrons,charge,charged_fragments)

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.BO2mol"><code class="name flex">
<span>def <span class="ident">BO2mol</span></span>(<span>mol, BO_matrix, atomicNumList, atomic_valence_electrons, mol_charge, charged_fragments)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BO2mol(mol,BO_matrix, atomicNumList,atomic_valence_electrons,mol_charge,charged_fragments):
# based on code written by Paolo Toscani

    l = len(BO_matrix)
    l2 = len(atomicNumList)
    BO_valences = list(BO_matrix.sum(axis=1))

    if (l != l2):
        raise RuntimeError(&#39;sizes of adjMat ({0:d}) and atomicNumList &#39;
            &#39;{1:d} differ&#39;.format(l, l2))

    rwMol = Chem.RWMol(mol)

    bondTypeDict = {
        1: Chem.BondType.SINGLE,
        2: Chem.BondType.DOUBLE,
        3: Chem.BondType.TRIPLE
    }

    for i in range(l):
        for j in range(i + 1, l):
            bo = int(round(BO_matrix[i, j]))
            if (bo == 0):
                continue
            bt = bondTypeDict.get(bo, Chem.BondType.SINGLE)
            rwMol.AddBond(i, j, bt)
    mol = rwMol.GetMol()

    if charged_fragments:
        mol = set_atomic_charges(mol,atomicNumList,atomic_valence_electrons,BO_valences,BO_matrix,mol_charge)
    else:
        mol = set_atomic_radicals(mol,atomicNumList,atomic_valence_electrons,BO_valences)

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.BO_is_OK"><code class="name flex">
<span>def <span class="ident">BO_is_OK</span></span>(<span>BO, AC, charge, DU, atomic_valence_electrons, atomicNumList, charged_fragments)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BO_is_OK(BO,AC,charge,DU,atomic_valence_electrons,atomicNumList,charged_fragments):
    Q = 0 # total charge
    q_list = []
    if charged_fragments:
        BO_valences = list(BO.sum(axis=1))
        for i,atom in enumerate(atomicNumList):
            q = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])
            Q += q
            if atom == 6:
                number_of_single_bonds_to_C = list(BO[i,:]).count(1)
                if number_of_single_bonds_to_C == 2 and BO_valences[i] == 2:
                    Q += 1
                    q = 2
                if number_of_single_bonds_to_C == 3 and Q + 1 &lt; charge:
                    Q += 2
                    q = 1

            if q != 0:
                q_list.append(q)

    if (BO-AC).sum() == sum(DU) and charge == Q and len(q_list) &lt;= abs(charge):
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.chiral_stereo_check"><code class="name flex">
<span>def <span class="ident">chiral_stereo_check</span></span>(<span>mol)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chiral_stereo_check(mol):
    Chem.SanitizeMol(mol)
    Chem.DetectBondStereochemistry(mol,-1)
    Chem.AssignStereochemistry(mol, flagPossibleStereoCenters=True, force=True)
    Chem.AssignAtomChiralTagsFromStructure(mol,-1)

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.clean_charges"><code class="name flex">
<span>def <span class="ident">clean_charges</span></span>(<span>mol)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_charges(mol):
# this hack should not be needed any more but is kept just in case
#

    rxn_smarts = [&#39;[N+:1]=[*:2]-[C-:3]&gt;&gt;[N+0:1]-[*:2]=[C-0:3]&#39;,
                  &#39;[N+:1]=[*:2]-[O-:3]&gt;&gt;[N+0:1]-[*:2]=[O-0:3]&#39;,
                  &#39;[N+:1]=[*:2]-[*:3]=[*:4]-[O-:5]&gt;&gt;[N+0:1]-[*:2]=[*:3]-[*:4]=[O-0:5]&#39;,
                  &#39;[#8:1]=[#6:2]([!-:6])[*:3]=[*:4][#6-:5]&gt;&gt;[*-:1][*:2]([*:6])=[*:3][*:4]=[*+0:5]&#39;,
                  &#39;[O:1]=[c:2][c-:3]&gt;&gt;[*-:1][*:2][*+0:3]&#39;,
                  &#39;[O:1]=[C:2][C-:3]&gt;&gt;[*-:1][*:2]=[*+0:3]&#39;]

    fragments = Chem.GetMolFrags(mol,asMols=True,sanitizeFrags=False)

    for i,fragment in enumerate(fragments):
        for smarts in rxn_smarts:
            patt = Chem.MolFromSmarts(smarts.split(&#34;&gt;&gt;&#34;)[0])
            while fragment.HasSubstructMatch(patt):
                rxn = AllChem.ReactionFromSmarts(smarts)
                ps = rxn.RunReactants((fragment,))
                fragment = ps[0][0]
        if i == 0:
            mol = fragment
        else:
            mol = Chem.CombineMols(mol,fragment)

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.getUA"><code class="name flex">
<span>def <span class="ident">getUA</span></span>(<span>maxValence_list, valence_list)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getUA(maxValence_list, valence_list):
    UA = []
    DU = []
    for i, (maxValence,valence) in enumerate(zip(maxValence_list, valence_list)):
        if maxValence - valence &gt; 0:
            UA.append(i)
            DU.append(maxValence - valence)
    return UA,DU</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_BO"><code class="name flex">
<span>def <span class="ident">get_BO</span></span>(<span>AC, UA, DU, valences, UA_pairs, quick)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_BO(AC,UA,DU,valences,UA_pairs,quick):
    BO = AC.copy()
    DU_save = []

    while DU_save != DU:
        for i,j in UA_pairs:
            BO[i,j] += 1
            BO[j,i] += 1

        BO_valence = list(BO.sum(axis=1))
        DU_save = copy.copy(DU)
        UA, DU = getUA(valences, BO_valence)
        UA_pairs = get_UA_pairs(UA,AC,quick)[0]

    return BO</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_UA_pairs"><code class="name flex">
<span>def <span class="ident">get_UA_pairs</span></span>(<span>UA, AC, quick)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_UA_pairs(UA,AC,quick):
    bonds = get_bonds(UA,AC)
    if len(bonds) == 0:
        return [()]

    if quick:
        G=nx.Graph()
        G.add_edges_from(bonds)
        UA_pairs = [list(nx.max_weight_matching(G))]
        return UA_pairs

    max_atoms_in_combo = 0
    UA_pairs = [()]
    for combo in list(itertools.combinations(bonds, int(len(UA)/2))):
        flat_list = [item for sublist in combo for item in sublist]
        atoms_in_combo = len(set(flat_list))
        if atoms_in_combo &gt; max_atoms_in_combo:
            max_atoms_in_combo = atoms_in_combo
            UA_pairs = [combo]
 #           if quick and max_atoms_in_combo == 2*int(len(UA)/2):
 #               return UA_pairs
        elif atoms_in_combo == max_atoms_in_combo:
            UA_pairs.append(combo)

    return UA_pairs</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atom"><code class="name flex">
<span>def <span class="ident">get_atom</span></span>(<span>atom)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atom(atom):
    global __ATOM_LIST__
    atom = atom.lower()
    return __ATOM_LIST__.index(atom) + 1</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomicNumList"><code class="name flex">
<span>def <span class="ident">get_atomicNumList</span></span>(<span>atomic_symbols)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atomicNumList(atomic_symbols):
    atomicNumList = []
    for symbol in atomic_symbols:
        atomicNumList.append(get_atom(symbol))
    return atomicNumList</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomic_charge"><code class="name flex">
<span>def <span class="ident">get_atomic_charge</span></span>(<span>atom, atomic_valence_electrons, BO_valence)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_atomic_charge(atom,atomic_valence_electrons,BO_valence):
    if atom == 1:
        charge = 1 - BO_valence
    elif atom == 5:
        charge = 3 - BO_valence
    elif atom == 15 and BO_valence == 5:
        charge = 0
    elif atom == 16 and BO_valence == 6:
        charge = 0
    else:
        charge = atomic_valence_electrons - 8 + BO_valence

    return charge</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_bonds"><code class="name flex">
<span>def <span class="ident">get_bonds</span></span>(<span>UA, AC)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bonds(UA,AC):
    bonds = []

    for k,i in enumerate(UA):
        for j in UA[k+1:]:
            if AC[i,j] == 1:
                bonds.append(tuple(sorted([i,j])))

    return bonds</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_proto_mol"><code class="name flex">
<span>def <span class="ident">get_proto_mol</span></span>(<span>atomicNumList)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proto_mol(atomicNumList):
    mol = Chem.MolFromSmarts(&#34;[#&#34;+str(atomicNumList[0])+&#34;]&#34;)
    rwMol = Chem.RWMol(mol)
    for i in range(1,len(atomicNumList)):
        a = Chem.Atom(atomicNumList[i])
        rwMol.AddAtom(a)

    mol = rwMol.GetMol()

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.read_xyz_file"><code class="name flex">
<span>def <span class="ident">read_xyz_file</span></span>(<span>filename)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_xyz_file(filename):

    atomic_symbols = []
    xyz_coordinates = []

    with open(filename, &#34;r&#34;) as file:
        for line_number,line in enumerate(file):
            if line_number == 0:
                num_atoms = int(line)
            elif line_number == 1:
                if &#34;charge=&#34; in line:
                    charge = int(line.split(&#34;=&#34;)[1])
                else:
                    charge = 0
            else:
                atomic_symbol, x, y, z = line.split()
                atomic_symbols.append(atomic_symbol)
                xyz_coordinates.append([float(x),float(y),float(z)])

    atomicNumList = get_atomicNumList(atomic_symbols)

    return atomicNumList,charge,xyz_coordinates</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_charges"><code class="name flex">
<span>def <span class="ident">set_atomic_charges</span></span>(<span>mol, atomicNumList, atomic_valence_electrons, BO_valences, BO_matrix, mol_charge)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_atomic_charges(mol,atomicNumList,atomic_valence_electrons,BO_valences,BO_matrix,mol_charge):
    q = 0
    for i,atom in enumerate(atomicNumList):
        a = mol.GetAtomWithIdx(i)
        charge = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])
        q += charge
        if atom == 6:
            number_of_single_bonds_to_C = list(BO_matrix[i,:]).count(1)
            if number_of_single_bonds_to_C == 2 and BO_valences[i] == 2:
                    q += 1
                    charge = 0
            if number_of_single_bonds_to_C == 3 and q + 1 &lt; mol_charge:
                    q += 2
                    charge = 1

        if (abs(charge) &gt; 0):
            a.SetFormalCharge(int(charge))

    # shouldn&#39;t be needed anymore bit is kept just in case
    #mol = clean_charges(mol)

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_radicals"><code class="name flex">
<span>def <span class="ident">set_atomic_radicals</span></span>(<span>mol, atomicNumList, atomic_valence_electrons, BO_valences)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_atomic_radicals(mol,atomicNumList,atomic_valence_electrons,BO_valences):
# The number of radical electrons = absolute atomic charge
    for i,atom in enumerate(atomicNumList):
        a = mol.GetAtomWithIdx(i)
        charge = get_atomic_charge(atom,atomic_valence_electrons[atom],BO_valences[i])

        if (abs(charge) &gt; 0):
            a.SetNumRadicalElectrons(abs(int(charge)))

    return mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.valences_not_too_large"><code class="name flex">
<span>def <span class="ident">valences_not_too_large</span></span>(<span>BO, valences)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def valences_not_too_large(BO,valences):
    number_of_bonds_list = BO.sum(axis=1)
    for valence, number_of_bonds in zip(valences,number_of_bonds_list):
        if number_of_bonds &gt; valence:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2AC"><code class="name flex">
<span>def <span class="ident">xyz2AC</span></span>(<span>atomicNumList, xyz)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz2AC(atomicNumList,xyz):
    import numpy as np
    mol = get_proto_mol(atomicNumList)

    conf = Chem.Conformer(mol.GetNumAtoms())
    for i in range(mol.GetNumAtoms()):
        conf.SetAtomPosition(i,(xyz[i][0],xyz[i][1],xyz[i][2]))
    mol.AddConformer(conf)

    dMat = Chem.Get3DDistanceMatrix(mol)
    pt = Chem.GetPeriodicTable()

    num_atoms = len(atomicNumList)
    AC = np.zeros((num_atoms,num_atoms)).astype(int)

    for i in range(num_atoms):
        a_i = mol.GetAtomWithIdx(i)
        Rcov_i = pt.GetRcovalent(a_i.GetAtomicNum())*1.30
        for j in range(i+1,num_atoms):
            a_j = mol.GetAtomWithIdx(j)
            Rcov_j = pt.GetRcovalent(a_j.GetAtomicNum())*1.30
            if dMat[i,j] &lt;= Rcov_i + Rcov_j:
                AC[i,j] = 1
                AC[j,i] = 1

    return AC,mol</code></pre>
</details>
</dd>
<dt id="autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2mol"><code class="name flex">
<span>def <span class="ident">xyz2mol</span></span>(<span>atomicNumList, charge, xyz_coordinates, charged_fragments, quick)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz2mol(atomicNumList,charge,xyz_coordinates,charged_fragments,quick):

# Get atom connectivity (AC) matrix, list of atomic numbers, molecular charge,
# and mol object with no connectivity information
    AC,mol = xyz2AC(atomicNumList,xyz_coordinates)

# Convert AC to bond order matrix and add connectivity and charge info to mol object
    new_mol = AC2mol(mol,AC,atomicNumList,charge,charged_fragments,quick)

# Check for stereocenters and chiral centers
    new_mol = chiral_stereo_check(new_mol)

    return new_mol</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="autoENRICH.ml.features.BCAI_calc" href="index.html">autoENRICH.ml.features.BCAI_calc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2BO" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2BO">AC2BO</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2mol" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.AC2mol">AC2mol</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.BO2mol" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.BO2mol">BO2mol</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.BO_is_OK" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.BO_is_OK">BO_is_OK</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.chiral_stereo_check" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.chiral_stereo_check">chiral_stereo_check</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.clean_charges" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.clean_charges">clean_charges</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.getUA" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.getUA">getUA</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_BO" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_BO">get_BO</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_UA_pairs" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_UA_pairs">get_UA_pairs</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atom" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atom">get_atom</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomicNumList" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomicNumList">get_atomicNumList</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomic_charge" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_atomic_charge">get_atomic_charge</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_bonds" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_bonds">get_bonds</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.get_proto_mol" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.get_proto_mol">get_proto_mol</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.read_xyz_file" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.read_xyz_file">read_xyz_file</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_charges" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_charges">set_atomic_charges</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_radicals" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.set_atomic_radicals">set_atomic_radicals</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.valences_not_too_large" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.valences_not_too_large">valences_not_too_large</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2AC" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2AC">xyz2AC</a></code></li>
<li><code><a title="autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2mol" href="#autoENRICH.ml.features.BCAI_calc.xyz2mol.xyz2mol">xyz2mol</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>